#!/usr/bin/python3
# qvm-remote-dom0-gui -- GTK3 graphical interface for qvm-remote-dom0 (dom0)
#
# Copyright (C) 2026  qvm-remote contributors
# SPDX-License-Identifier: GPL-2.0-or-later

"""Graphical interface for the qvm-remote dom0 service manager.

Provides a tabbed interface for monitoring service status, managing
authorized virtual machines, and viewing the daemon log.
Built with GTK3 following Qubes OS 4.3 UI conventions.
"""

from __future__ import annotations

import os
import sys
import threading
from pathlib import Path

_self_dir = os.path.dirname(os.path.abspath(__file__))
for _p in [_self_dir, "/usr/lib/qvm-remote"]:
    _mod = os.path.join(_p, "qubes_remote_ui.py")
    if os.path.isfile(_mod) and _p not in sys.path:
        sys.path.insert(0, _p)
        break

from qubes_remote_ui import check_display, require_gtk  # noqa: E402

_disp_err = check_display()
if _disp_err:
    print(f"qvm-remote-dom0-gui: {_disp_err}", file=sys.stderr)
    sys.exit(1)
require_gtk()

import gi  # noqa: E402

gi.require_version("Gtk", "3.0")
from gi.repository import Gtk, Gdk, GLib, Pango  # noqa: E402

from qubes_remote_ui import (  # noqa: E402
    UI_VERSION,
    QUBES_COLORS,
    apply_css,
    create_header_bar,
    create_frame,
    create_info_row,
    show_error_dialog,
    show_info_dialog,
    show_confirm_dialog,
    valid_hex_key,
    OutputView,
    StatusIndicator,
    run_quick,
    find_executable,
    send_notification,
    format_file_size,
    create_local_backup,
    restore_local_backup,
    list_local_backups,
    get_change_summary,
    NOTIFY_ICON_INFO,
    NOTIFY_ICON_SUCCESS,
    NOTIFY_ICON_WARNING,
    NOTIFY_ICON_ERROR,
    NOTIFY_ICON_SECURITY,
    NOTIFY_ICON_NETWORK,
    NOTIFY_ICON_TRANSFER,
    NOTIFY_ICON_BACKUP,
)

APP_ID = "org.qubes-os.qvm-remote-dom0-gui"
SERVICE_NAME = "qvm-remote-dom0"
LOG_FILE = Path("/var/log/qubes/qvm-remote.log")
KEYS_DIR = Path("/etc/qubes/remote.d")
CONF_FILE = Path("/etc/qubes/remote.conf")


# ── Main window ─────────────────────────────────────────────────────


class QvmRemoteDom0Window(Gtk.ApplicationWindow):
    """Dom0 service manager window with Dashboard, VMs, and Log tabs."""

    def __init__(self, app):
        super().__init__(application=app, title="Qubes Remote Service Manager")
        self.set_default_size(850, 620)
        self.set_position(Gtk.WindowPosition.CENTER)

        self._dom0_bin = find_executable(
            "qvm-remote-dom0",
            [os.path.join(_self_dir, "..", "dom0")],
        )

        header = create_header_bar(
            "Qubes Remote Service Manager",
            "Manage the dom0 command executor",
        )
        self.set_titlebar(header)

        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.add(vbox)

        # Warn if not running as root (dom0 operations require root)
        if os.getuid() != 0:
            infobar = Gtk.InfoBar()
            infobar.set_message_type(Gtk.MessageType.WARNING)
            lbl = Gtk.Label(
                label="Not running as root. Service controls and key "
                "management may not work. Run with: sudo qvm-remote-dom0-gui"
            )
            lbl.set_line_wrap(True)
            infobar.get_content_area().add(lbl)
            infobar.set_show_close_button(True)
            infobar.connect("response", lambda bar, resp: bar.hide())
            vbox.pack_start(infobar, False, False, 0)

        self._notebook = Gtk.Notebook()
        self._notebook.set_tab_pos(Gtk.PositionType.TOP)
        self._notebook.connect("switch-page", self._on_tab_switch)
        vbox.pack_start(self._notebook, True, True, 0)

        self._build_dashboard_tab()
        self._build_vms_tab()
        self._build_backup_tab()
        self._build_log_tab()

        # Auto-refresh dashboard every 10 seconds
        self._refresh_timer = GLib.timeout_add_seconds(10, self._auto_refresh)
        GLib.timeout_add(300, self._initial_refresh)

    def _initial_refresh(self):
        self._refresh_dashboard()
        return False

    # ── Dashboard tab ───────────────────────────────────────────────

    def _build_dashboard_tab(self):
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)
        vbox.set_margin_start(20)
        vbox.set_margin_end(20)
        vbox.set_margin_top(20)
        vbox.set_margin_bottom(20)

        # Service status section
        frame = create_frame("Service Status")
        fbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        fbox.set_margin_start(12)
        fbox.set_margin_end(12)
        fbox.set_margin_top(8)
        fbox.set_margin_bottom(8)

        self._svc_status = StatusIndicator("Checking...", "inactive")
        fbox.pack_start(self._svc_status, False, False, 0)

        row, self._svc_active = create_info_row("Active:", "")
        fbox.pack_start(row, False, False, 0)

        row, self._svc_enabled = create_info_row("Autostart:", "")
        fbox.pack_start(row, False, False, 0)

        row, self._svc_pid = create_info_row("Process ID:", "")
        fbox.pack_start(row, False, False, 0)

        row, self._svc_vms = create_info_row("Authorized VMs:", "")
        fbox.pack_start(row, False, False, 0)

        frame.add(fbox)
        vbox.pack_start(frame, False, False, 0)

        # Quick actions
        frame2 = create_frame("Quick Actions")
        btn_grid = Gtk.Grid()
        btn_grid.set_column_spacing(8)
        btn_grid.set_row_spacing(8)
        btn_grid.set_margin_start(12)
        btn_grid.set_margin_end(12)
        btn_grid.set_margin_top(8)
        btn_grid.set_margin_bottom(8)

        self._start_btn = Gtk.Button(label="Start Service")
        self._start_btn.connect("clicked", self._on_start)
        self._start_btn.set_tooltip_text("Start the remote command executor")
        btn_grid.attach(self._start_btn, 0, 0, 1, 1)

        self._stop_btn = Gtk.Button(label="Stop Service")
        self._stop_btn.connect("clicked", self._on_stop)
        self._stop_btn.set_tooltip_text("Stop the remote command executor")
        ctx = self._stop_btn.get_style_context()
        ctx.add_class("destructive-action")
        btn_grid.attach(self._stop_btn, 1, 0, 1, 1)

        self._restart_btn = Gtk.Button(label="Restart Service")
        self._restart_btn.connect("clicked", self._on_restart)
        btn_grid.attach(self._restart_btn, 2, 0, 1, 1)

        self._enable_btn = Gtk.Button(label="Enable Autostart")
        self._enable_btn.connect("clicked", self._on_enable)
        self._enable_btn.set_tooltip_text(
            "Start service automatically on every boot"
        )
        btn_grid.attach(self._enable_btn, 0, 1, 1, 1)

        self._disable_btn = Gtk.Button(label="Disable Autostart")
        self._disable_btn.connect("clicked", self._on_disable)
        btn_grid.attach(self._disable_btn, 1, 1, 1, 1)

        refresh_btn = Gtk.Button(label="Refresh Status")
        refresh_btn.connect("clicked", lambda b: self._refresh_dashboard())
        btn_grid.attach(refresh_btn, 2, 1, 1, 1)

        frame2.add(btn_grid)
        vbox.pack_start(frame2, False, False, 0)

        # Recent activity
        frame3 = create_frame("Recent Activity")
        self._activity_view = OutputView()
        self._activity_view.set_min_content_height(120)
        frame3.add(self._activity_view)
        vbox.pack_start(frame3, True, True, 0)

        self._notebook.append_page(vbox, Gtk.Label(label="Dashboard"))

    def _refresh_dashboard(self):
        """Refresh all dashboard information."""
        self._refresh_service_status()
        self._refresh_vm_count()
        self._refresh_recent_activity()

    def _refresh_service_status(self):
        def _check():
            rc, out, err = run_quick(
                ["systemctl", "is-active", SERVICE_NAME], timeout=5
            )
            active = out.strip() == "active"

            rc2, out2, _ = run_quick(
                ["systemctl", "is-enabled", SERVICE_NAME], timeout=5
            )
            enabled = out2.strip() == "enabled"

            pid = ""
            if active:
                rc3, out3, _ = run_quick(
                    ["systemctl", "show", "-p", "MainPID", SERVICE_NAME], timeout=5
                )
                if rc3 == 0 and "=" in out3:
                    pid = out3.strip().split("=", 1)[1]

            GLib.idle_add(self._update_status_ui, active, enabled, pid)

        threading.Thread(target=_check, daemon=True).start()

    def _update_status_ui(self, active, enabled, pid):
        if active:
            self._svc_status.set_state("active", "Running")
            self._svc_active.set_text("active (running)")
            self._start_btn.set_sensitive(False)
            self._stop_btn.set_sensitive(True)
            self._restart_btn.set_sensitive(True)
        else:
            self._svc_status.set_state("inactive", "Stopped")
            self._svc_active.set_text("inactive (stopped)")
            self._start_btn.set_sensitive(True)
            self._stop_btn.set_sensitive(False)
            self._restart_btn.set_sensitive(False)

        self._svc_enabled.set_text("yes" if enabled else "no")
        self._enable_btn.set_sensitive(not enabled)
        self._disable_btn.set_sensitive(enabled)
        self._svc_pid.set_text(pid if pid and pid != "0" else "-")
        return False

    def _refresh_vm_count(self):
        count = 0
        if KEYS_DIR.exists():
            try:
                count = len(list(KEYS_DIR.glob("*.key")))
            except OSError:
                pass
        self._svc_vms.set_text(str(count))

    def _refresh_recent_activity(self):
        self._activity_view.clear()
        if not LOG_FILE.exists():
            self._activity_view.append("No log entries yet.\n", "info")
            return
        try:
            lines = LOG_FILE.read_text().splitlines()
            for line in lines[-15:]:
                tag = "stdout"
                lower = line.lower()
                if "error" in lower or "reject" in lower or "auth-fail" in lower:
                    tag = "stderr"
                elif "done" in lower:
                    tag = "success"
                elif "exec" in lower or "cmd" in lower:
                    tag = "info"
                self._activity_view.append(line + "\n", tag)
        except OSError as e:
            self._activity_view.append(f"Error reading log: {e}\n", "stderr")

    def _auto_refresh(self):
        if self._notebook.get_current_page() == 0:
            self._refresh_dashboard()
        return True

    # ── Service controls ────────────────────────────────────────────

    def _run_systemctl(self, action, confirm_msg=None):
        if confirm_msg:
            if not show_confirm_dialog(self, f"{action.title()} Service", confirm_msg):
                return

        def _do():
            rc, out, err = run_quick(["systemctl", action, SERVICE_NAME], timeout=30)
            GLib.idle_add(self._systemctl_done, action, rc, err)

        threading.Thread(target=_do, daemon=True).start()

    def _systemctl_done(self, action, rc, err):
        if rc == 0:
            self._refresh_dashboard()
            send_notification(
                f"Service {action}ed",
                f"The remote command executor has been {action}ed.",
                icon=NOTIFY_ICON_SUCCESS,
            )
        else:
            show_error_dialog(
                self,
                f"Failed to {action} service",
                err.strip() or f"systemctl {action} returned exit code {rc}",
            )
            send_notification(
                f"Failed to {action} service",
                err.strip() or f"Exit code {rc}",
                icon=NOTIFY_ICON_ERROR, urgency="critical",
            )
        return False

    def _on_start(self, _btn):
        self._run_systemctl("start")

    def _on_stop(self, _btn):
        self._run_systemctl(
            "stop",
            "This will stop the remote command executor.\n"
            "VMs will not be able to run commands in dom0 until restarted.",
        )

    def _on_restart(self, _btn):
        self._run_systemctl("restart")

    def _on_enable(self, _btn):
        if not show_confirm_dialog(
            self,
            "Enable Autostart?",
            "This will automatically start the remote command executor on "
            "every boot.\n\n"
            "Any authorized VM will be able to execute arbitrary commands "
            "in dom0 with full root privileges whenever the system is running.\n\n"
            "A compromise of any authorized VM would give an attacker "
            "complete control over dom0 and every other VM.\n\n"
            "Are you sure?",
        ):
            return
        self._run_systemctl("enable")

    def _on_disable(self, _btn):
        def _do():
            run_quick(["systemctl", "disable", SERVICE_NAME], timeout=10)
            run_quick(["systemctl", "stop", SERVICE_NAME], timeout=10)
            GLib.idle_add(self._refresh_dashboard)
            send_notification(
                "Autostart disabled",
                "Service stopped and will not start on boot.",
                icon=NOTIFY_ICON_INFO,
            )

        threading.Thread(target=_do, daemon=True).start()

    # ── VMs tab ─────────────────────────────────────────────────────

    def _build_vms_tab(self):
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        vbox.set_margin_start(12)
        vbox.set_margin_end(12)
        vbox.set_margin_top(12)
        vbox.set_margin_bottom(12)

        # VM list
        # Columns: VM Name, Key (masked), Key File
        self._vm_store = Gtk.ListStore(str, str, str)
        self._vm_tree = Gtk.TreeView(model=self._vm_store)
        self._vm_tree.set_headers_visible(True)

        for i, (title, width) in enumerate(
            [("VM Name", 200), ("Key (first 16 chars)", 220), ("Key File", 300)]
        ):
            renderer = Gtk.CellRendererText()
            if i == 1:
                renderer.set_property("family", "monospace")
            col = Gtk.TreeViewColumn(title, renderer, text=i)
            col.set_resizable(True)
            col.set_min_width(width)
            col.set_sort_column_id(i)
            self._vm_tree.append_column(col)

        scroll = Gtk.ScrolledWindow()
        scroll.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        scroll.set_vexpand(True)
        scroll.add(self._vm_tree)
        vbox.pack_start(scroll, True, True, 0)

        # Action buttons
        btn_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=8)

        revoke_btn = Gtk.Button(label="Revoke Selected")
        revoke_btn.set_tooltip_text("Remove authorization for the selected VM")
        revoke_btn.connect("clicked", self._on_revoke)
        ctx = revoke_btn.get_style_context()
        ctx.add_class("destructive-action")
        btn_box.pack_start(revoke_btn, False, False, 0)

        refresh_btn = Gtk.Button(label="Refresh")
        refresh_btn.connect("clicked", lambda b: self._load_vms())
        btn_box.pack_start(refresh_btn, False, False, 0)

        btn_box.pack_start(Gtk.Box(), True, True, 0)
        vbox.pack_start(btn_box, False, False, 0)

        # Separator
        sep = Gtk.Separator(orientation=Gtk.Orientation.HORIZONTAL)
        vbox.pack_start(sep, False, False, 4)

        # Authorize new VM
        frame = create_frame("Authorize New VM")
        grid = Gtk.Grid()
        grid.set_column_spacing(8)
        grid.set_row_spacing(8)
        grid.set_margin_start(12)
        grid.set_margin_end(12)
        grid.set_margin_top(8)
        grid.set_margin_bottom(8)

        lbl1 = Gtk.Label(label="VM name:")
        lbl1.set_halign(Gtk.Align.END)
        grid.attach(lbl1, 0, 0, 1, 1)

        self._auth_vm_entry = Gtk.Entry()
        self._auth_vm_entry.set_placeholder_text("e.g. work, personal")
        self._auth_vm_entry.set_hexpand(True)
        grid.attach(self._auth_vm_entry, 1, 0, 1, 1)

        lbl2 = Gtk.Label(label="Key (hex):")
        lbl2.set_halign(Gtk.Align.END)
        grid.attach(lbl2, 0, 1, 1, 1)

        self._auth_key_entry = Gtk.Entry()
        self._auth_key_entry.set_placeholder_text("64 hex characters from the VM's qvm-remote key gen")
        self._auth_key_entry.set_max_length(64)
        self._auth_key_entry.set_hexpand(True)
        self._auth_key_entry.set_visibility(True)
        grid.attach(self._auth_key_entry, 1, 1, 1, 1)

        auth_btn = Gtk.Button(label="Authorize")
        auth_btn.set_tooltip_text("Register this VM to execute commands in dom0")
        auth_btn.connect("clicked", self._on_authorize)
        ctx = auth_btn.get_style_context()
        ctx.add_class("suggested-action")
        grid.attach(auth_btn, 2, 1, 1, 1)

        frame.add(grid)
        vbox.pack_start(frame, False, False, 0)

        # ── File operations ──────────────────────────────────
        sep2 = Gtk.Separator(orientation=Gtk.Orientation.HORIZONTAL)
        vbox.pack_start(sep2, False, False, 4)

        frame_files = create_frame("Push File to VM")
        file_grid = Gtk.Grid()
        file_grid.set_column_spacing(8)
        file_grid.set_row_spacing(8)
        file_grid.set_margin_start(12)
        file_grid.set_margin_end(12)
        file_grid.set_margin_top(8)
        file_grid.set_margin_bottom(8)

        lbl_vm = Gtk.Label(label="Target VM:")
        lbl_vm.set_halign(Gtk.Align.END)
        file_grid.attach(lbl_vm, 0, 0, 1, 1)

        self._push_vm_entry = Gtk.Entry()
        self._push_vm_entry.set_placeholder_text("e.g. work")
        self._push_vm_entry.set_hexpand(True)
        file_grid.attach(self._push_vm_entry, 1, 0, 1, 1)

        lbl_src = Gtk.Label(label="Dom0 file:")
        lbl_src.set_halign(Gtk.Align.END)
        file_grid.attach(lbl_src, 0, 1, 1, 1)

        self._push_src_entry = Gtk.Entry()
        self._push_src_entry.set_placeholder_text("/tmp/file.txt")
        self._push_src_entry.set_hexpand(True)
        file_grid.attach(self._push_src_entry, 1, 1, 1, 1)

        lbl_dst = Gtk.Label(label="VM path:")
        lbl_dst.set_halign(Gtk.Align.END)
        file_grid.attach(lbl_dst, 0, 2, 1, 1)

        self._push_dst_entry = Gtk.Entry()
        self._push_dst_entry.set_placeholder_text("/home/user/file.txt")
        self._push_dst_entry.set_hexpand(True)
        file_grid.attach(self._push_dst_entry, 1, 2, 1, 1)

        self._push_btn = Gtk.Button(label="Push to VM")
        self._push_btn.set_tooltip_text(
            "Copy a file from dom0 to a VM using qvm-run "
            "(uses pass-io, follows Qubes security model)"
        )
        self._push_btn.connect("clicked", self._on_push_file)
        ctx = self._push_btn.get_style_context()
        ctx.add_class("suggested-action")
        file_grid.attach(self._push_btn, 2, 2, 1, 1)

        self._push_output = OutputView()
        self._push_output.set_min_content_height(60)

        frame_files.add(file_grid)
        vbox.pack_start(frame_files, False, False, 0)
        vbox.pack_start(self._push_output, True, True, 0)

        self._notebook.append_page(vbox, Gtk.Label(label="Virtual Machines"))

    def _load_vms(self):
        self._vm_store.clear()
        if not KEYS_DIR.exists():
            return
        try:
            for kf in sorted(KEYS_DIR.glob("*.key")):
                vm_name = kf.stem
                try:
                    key = kf.read_text().strip()
                    masked = key[:16] + "..." if len(key) >= 16 else key
                except OSError:
                    masked = "(unreadable)"
                self._vm_store.append([vm_name, masked, str(kf)])
        except OSError:
            pass

    def _on_authorize(self, _btn):
        vm = self._auth_vm_entry.get_text().strip()
        key = self._auth_key_entry.get_text().strip()

        if not vm:
            show_error_dialog(self, "Missing VM Name", "Please enter a VM name.")
            return
        if not valid_hex_key(key):
            show_error_dialog(
                self,
                "Invalid Key",
                "The key must be exactly 64 hexadecimal characters (0-9, a-f).\n"
                "Generate one in the VM with: qvm-remote key gen",
            )
            return

        if not self._dom0_bin:
            show_error_dialog(self, "Tool Not Found", "qvm-remote-dom0 not found.")
            return

        rc, out, err = run_quick([self._dom0_bin, "authorize", vm, key])
        if rc == 0:
            show_info_dialog(self, "VM Authorized", out.strip() or f"VM '{vm}' authorized.")
            self._auth_vm_entry.set_text("")
            self._auth_key_entry.set_text("")
            self._load_vms()
            self._refresh_vm_count()
            send_notification(
                f"VM '{vm}' authorized",
                "This VM can now execute commands in dom0.",
                icon=NOTIFY_ICON_SECURITY,
                urgency="critical",
            )
        else:
            show_error_dialog(
                self, "Authorization Failed", err.strip() or "Unknown error"
            )
            send_notification(
                "VM authorization failed",
                err.strip() or "Unknown error",
                icon=NOTIFY_ICON_ERROR, urgency="critical",
            )

    def _on_revoke(self, _btn):
        sel = self._vm_tree.get_selection()
        model, tree_iter = sel.get_selected()
        if not tree_iter:
            show_error_dialog(
                self, "No Selection", "Select a VM from the list to revoke."
            )
            return

        vm = model[tree_iter][0]
        if not show_confirm_dialog(
            self,
            f"Revoke '{vm}'?",
            f"This will remove the authentication key for '{vm}'.\n"
            "The VM will no longer be able to execute commands in dom0.",
        ):
            return

        if not self._dom0_bin:
            show_error_dialog(self, "Tool Not Found", "qvm-remote-dom0 not found.")
            return

        rc, out, err = run_quick([self._dom0_bin, "revoke", vm])
        if rc == 0:
            show_info_dialog(self, "VM Revoked", f"Authorization removed for '{vm}'.")
            self._load_vms()
            self._refresh_vm_count()
            send_notification(
                f"VM '{vm}' revoked",
                "This VM can no longer execute commands in dom0.",
                icon=NOTIFY_ICON_SECURITY,
            )
        else:
            show_error_dialog(self, "Revocation Failed", err.strip() or "Unknown error")
            send_notification(
                "VM revocation failed",
                err.strip() or "Unknown error",
                icon=NOTIFY_ICON_ERROR, urgency="critical",
            )

    def _on_push_file(self, _btn):
        vm = self._push_vm_entry.get_text().strip()
        src = self._push_src_entry.get_text().strip()
        dst = self._push_dst_entry.get_text().strip()

        if not all([vm, src, dst]):
            show_error_dialog(
                self, "Missing Information",
                "Fill in the target VM name, dom0 file path, and VM destination path.",
            )
            return
        if not os.path.isfile(src):
            show_error_dialog(self, "File Not Found", f"Cannot find: {src}")
            return

        size = os.path.getsize(src)
        if not show_confirm_dialog(
            self,
            f"Push File to '{vm}'?",
            f"This will copy:\n"
            f"  dom0:{src} ({format_file_size(size)})\n"
            f"    to\n"
            f"  {vm}:{dst}\n\n"
            f"The file is sent using qvm-run with pass-io.\n"
            f"The target VM must be running.",
        ):
            return

        self._push_output.clear()
        self._push_output.append(
            f"Pushing {os.path.basename(src)} ({format_file_size(size)}) "
            f"to {vm}:{dst}...\n", "info",
        )
        self._push_btn.set_sensitive(False)
        send_notification(
            f"Pushing file to '{vm}'",
            f"{os.path.basename(src)} ({format_file_size(size)})",
            icon=NOTIFY_ICON_TRANSFER,
        )

        import shlex
        safe_dst = shlex.quote(dst)

        def _do_push():
            try:
                with open(src, "rb") as f:
                    data = f.read()
            except OSError as e:
                GLib.idle_add(
                    self._push_output.append,
                    f"Error reading file: {e}\n", "stderr",
                )
                GLib.idle_add(self._push_btn.set_sensitive, True)
                return

            import subprocess as sp
            try:
                r = sp.run(
                    ["qvm-run", "--pass-io", "--no-gui", vm,
                     f"cat > {safe_dst}"],
                    input=data,
                    capture_output=True,
                    timeout=120,
                )
                rc = r.returncode
                err = r.stderr.decode(errors="replace")
            except Exception as e:
                GLib.idle_add(
                    self._push_output.append,
                    f"Error: {e}\n", "stderr",
                )
                GLib.idle_add(self._push_btn.set_sensitive, True)
                return

            if rc == 0:
                GLib.idle_add(
                    self._push_output.append,
                    f"File pushed successfully to {vm}:{dst}\n", "success",
                )
                send_notification(
                    f"File pushed to '{vm}'",
                    f"{os.path.basename(src)} saved to {dst}",
                    icon=NOTIFY_ICON_SUCCESS,
                )
            else:
                GLib.idle_add(
                    self._push_output.append,
                    f"Push failed (exit {rc}): {err}\n", "stderr",
                )
                send_notification(
                    "File push failed",
                    err.strip() or f"Exit code {rc}",
                    icon=NOTIFY_ICON_ERROR, urgency="critical",
                )
            GLib.idle_add(self._push_btn.set_sensitive, True)

        threading.Thread(target=_do_push, daemon=True).start()

    # ── Backup tab ──────────────────────────────────────────────────
    # Dom0 backup management: system backups, service config backup,
    # change history, and rollback capabilities.

    def _build_backup_tab(self):
        scroll = Gtk.ScrolledWindow()
        scroll.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        vbox.set_margin_start(12)
        vbox.set_margin_end(12)
        vbox.set_margin_top(12)
        vbox.set_margin_bottom(12)

        # ── Dom0 Backup Status ───────────────────────────────
        frame_status = create_frame("Dom0 System Backup Status")
        status_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        status_box.set_margin_start(12)
        status_box.set_margin_end(12)
        status_box.set_margin_top(8)
        status_box.set_margin_bottom(8)

        row, self._bak_last_date = create_info_row("Last backup:", "Checking...")
        status_box.pack_start(row, False, False, 0)

        row, self._bak_location = create_info_row("Backup location:", "-")
        status_box.pack_start(row, False, False, 0)

        row, self._bak_disk_info = create_info_row("Disk space:", "-")
        status_box.pack_start(row, False, False, 0)

        check_btn = Gtk.Button(label="Refresh Backup Status")
        check_btn.connect("clicked", lambda b: self._refresh_backup_status())
        status_box.pack_start(check_btn, False, False, 0)

        frame_status.add(status_box)
        vbox.pack_start(frame_status, False, False, 0)

        # ── Create New Backup ────────────────────────────────
        frame_create = create_frame("Create New Dom0 Backup")
        create_grid = Gtk.Grid()
        create_grid.set_column_spacing(8)
        create_grid.set_row_spacing(8)
        create_grid.set_margin_start(12)
        create_grid.set_margin_end(12)
        create_grid.set_margin_top(8)
        create_grid.set_margin_bottom(8)

        lbl_dest = Gtk.Label(label="Backup destination:")
        lbl_dest.set_halign(Gtk.Align.END)
        create_grid.attach(lbl_dest, 0, 0, 1, 1)

        self._bak_dest_entry = Gtk.Entry()
        self._bak_dest_entry.set_placeholder_text(
            "/mnt/backup/ or external drive mount point"
        )
        self._bak_dest_entry.set_hexpand(True)
        create_grid.attach(self._bak_dest_entry, 1, 0, 2, 1)

        lbl_vms = Gtk.Label(label="VMs to include:")
        lbl_vms.set_halign(Gtk.Align.END)
        create_grid.attach(lbl_vms, 0, 1, 1, 1)

        self._bak_vms_entry = Gtk.Entry()
        self._bak_vms_entry.set_placeholder_text(
            "Leave empty for all, or: work personal vault"
        )
        self._bak_vms_entry.set_hexpand(True)
        create_grid.attach(self._bak_vms_entry, 1, 1, 1, 1)

        self._bak_start_btn = Gtk.Button(label="Start Backup")
        self._bak_start_btn.set_tooltip_text(
            "Create a new Qubes backup (encrypted, compressed)"
        )
        self._bak_start_btn.connect("clicked", self._on_create_dom0_backup)
        ctx = self._bak_start_btn.get_style_context()
        ctx.add_class("suggested-action")
        create_grid.attach(self._bak_start_btn, 2, 1, 1, 1)

        # Exclude VMs option
        lbl_exclude = Gtk.Label(label="Exclude VMs:")
        lbl_exclude.set_halign(Gtk.Align.END)
        create_grid.attach(lbl_exclude, 0, 2, 1, 1)

        self._bak_exclude_entry = Gtk.Entry()
        self._bak_exclude_entry.set_placeholder_text(
            "Optional: VMs to exclude (e.g. large-vm)"
        )
        self._bak_exclude_entry.set_hexpand(True)
        create_grid.attach(self._bak_exclude_entry, 1, 2, 2, 1)

        frame_create.add(create_grid)
        vbox.pack_start(frame_create, False, False, 0)

        # ── Service Config Backup ────────────────────────────
        frame_svc = create_frame("Service Configuration Backup")
        svc_grid = Gtk.Grid()
        svc_grid.set_column_spacing(8)
        svc_grid.set_row_spacing(8)
        svc_grid.set_margin_start(12)
        svc_grid.set_margin_end(12)
        svc_grid.set_margin_top(8)
        svc_grid.set_margin_bottom(8)

        svc_info = Gtk.Label()
        svc_info.set_markup(
            '<span size="small" foreground="#888888">'
            "Backs up service configuration: authorized VM keys, remote.conf, "
            "and daemon log. Useful for quick recovery of the remote executor setup."
            "</span>"
        )
        svc_info.set_line_wrap(True)
        svc_info.set_halign(Gtk.Align.START)
        svc_grid.attach(svc_info, 0, 0, 3, 1)

        lbl_svc_dir = Gtk.Label(label="Config backup dir:")
        lbl_svc_dir.set_halign(Gtk.Align.END)
        svc_grid.attach(lbl_svc_dir, 0, 1, 1, 1)

        self._svc_backup_dir = Gtk.Entry()
        self._svc_backup_dir.set_text("/var/backups/qvm-remote")
        self._svc_backup_dir.set_hexpand(True)
        svc_grid.attach(self._svc_backup_dir, 1, 1, 1, 1)

        svc_bak_btn = Gtk.Button(label="Backup Config")
        svc_bak_btn.set_tooltip_text(
            "Backup /etc/qubes/remote.conf and VM keys"
        )
        svc_bak_btn.connect("clicked", self._on_backup_service_config)
        ctx = svc_bak_btn.get_style_context()
        ctx.add_class("suggested-action")
        svc_grid.attach(svc_bak_btn, 2, 1, 1, 1)

        # Restore config
        lbl_svc_restore = Gtk.Label(label="Restore from:")
        lbl_svc_restore.set_halign(Gtk.Align.END)
        svc_grid.attach(lbl_svc_restore, 0, 2, 1, 1)

        self._svc_restore_combo = Gtk.ComboBoxText()
        self._svc_restore_combo.set_hexpand(True)
        svc_grid.attach(self._svc_restore_combo, 1, 2, 1, 1)

        svc_restore_btn = Gtk.Button(label="Restore Config")
        svc_restore_btn.set_tooltip_text(
            "Restore service configuration from a backup archive"
        )
        svc_restore_btn.connect("clicked", self._on_restore_service_config)
        ctx = svc_restore_btn.get_style_context()
        ctx.add_class("destructive-action")
        svc_grid.attach(svc_restore_btn, 2, 2, 1, 1)

        frame_svc.add(svc_grid)
        vbox.pack_start(frame_svc, False, False, 0)

        # ── Recent Changes / Rollback ────────────────────────
        frame_changes = create_frame("Recent Changes and Rollback")
        changes_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=4)
        changes_box.set_margin_start(12)
        changes_box.set_margin_end(12)
        changes_box.set_margin_top(8)
        changes_box.set_margin_bottom(8)

        self._dom0_changes_view = OutputView()
        self._dom0_changes_view.set_min_content_height(100)
        changes_box.pack_start(self._dom0_changes_view, True, True, 0)

        changes_btn_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=8)
        refresh_changes_btn = Gtk.Button(label="Refresh Changes")
        refresh_changes_btn.connect("clicked", lambda b: self._load_dom0_changes())
        changes_btn_box.pack_start(refresh_changes_btn, False, False, 0)
        changes_box.pack_start(changes_btn_box, False, False, 0)

        frame_changes.add(changes_box)
        vbox.pack_start(frame_changes, False, False, 0)

        # ── Backup output ────────────────────────────────────
        self._backup_output = OutputView()
        self._backup_output.set_min_content_height(80)
        vbox.pack_start(self._backup_output, True, True, 0)

        scroll.add(vbox)
        self._notebook.append_page(scroll, Gtk.Label(label="Backup"))

    def _refresh_backup_status(self):
        """Check for existing Qubes backups and disk space."""
        def _check():
            # Find latest backup file
            import glob as _glob
            last_backup = "No backups found"
            location = "-"
            for bak_dir in ["/var/backups", "/mnt/backup"]:
                try:
                    files = sorted(
                        Path(bak_dir).glob("qubes-backup*"),
                        key=lambda p: p.stat().st_mtime,
                        reverse=True,
                    )
                    if files:
                        from datetime import datetime
                        f = files[0]
                        mtime = datetime.fromtimestamp(f.stat().st_mtime)
                        last_backup = mtime.strftime("%Y-%m-%d %H:%M")
                        location = str(f.parent)
                        break
                except OSError:
                    continue

            # Get disk info for common backup locations
            disk_info = ""
            for d in ["/var/backups", "/mnt/backup", "/mnt/usb"]:
                if os.path.isdir(d):
                    rc, out, _ = run_quick(["df", "-h", d], timeout=5)
                    if rc == 0:
                        lines = out.strip().splitlines()
                        if len(lines) >= 2:
                            parts = lines[1].split()
                            if len(parts) >= 4:
                                disk_info += f"{d}: {parts[3]} free  "

            GLib.idle_add(self._bak_last_date.set_text, last_backup)
            GLib.idle_add(self._bak_location.set_text, location)
            GLib.idle_add(
                self._bak_disk_info.set_text,
                disk_info.strip() if disk_info else "No known backup locations",
            )

        threading.Thread(target=_check, daemon=True).start()

    def _on_create_dom0_backup(self, _btn):
        dest = self._bak_dest_entry.get_text().strip()
        if not dest:
            show_error_dialog(
                self, "No Destination",
                "Enter a backup destination path (e.g. /mnt/backup/).",
            )
            return
        if not os.path.isdir(dest):
            show_error_dialog(
                self, "Directory Not Found",
                f"The directory does not exist: {dest}\n"
                "Mount the backup drive first.",
            )
            return

        vms = self._bak_vms_entry.get_text().strip()
        excludes = self._bak_exclude_entry.get_text().strip()

        desc_parts = [f"Destination: {dest}"]
        if vms:
            desc_parts.append(f"VMs: {vms}")
        else:
            desc_parts.append("All VMs with include_in_backups=True")
        if excludes:
            desc_parts.append(f"Excluding: {excludes}")
        desc = "\n".join(desc_parts)

        if not show_confirm_dialog(
            self,
            "Start Full Dom0 Backup?",
            f"This will create a Qubes backup.\n\n{desc}\n\n"
            "The backup will be encrypted and compressed.\n"
            "This can take a long time depending on data size.\n\n"
            "Are you sure?",
        ):
            return

        self._backup_output.clear()
        self._backup_output.append(f"Starting backup to {dest}...\n", "info")
        self._bak_start_btn.set_sensitive(False)
        send_notification(
            "Dom0 backup starting",
            desc_parts[0],
            icon=NOTIFY_ICON_BACKUP,
        )

        import shlex
        cmd_parts = ["qvm-backup", "--yes"]
        if excludes:
            for ex in excludes.split():
                cmd_parts.extend(["-x", shlex.quote(ex)])
        cmd_parts.append(shlex.quote(dest))
        if vms:
            cmd_parts.extend(shlex.quote(v) for v in vms.split())
        cmd = " ".join(cmd_parts)

        def _do():
            import subprocess as sp
            try:
                r = sp.run(
                    cmd, shell=True,
                    capture_output=True, text=True,
                    timeout=7200,
                )
                rc = r.returncode
                out = r.stdout
                err = r.stderr
            except sp.TimeoutExpired:
                GLib.idle_add(
                    self._backup_output.append,
                    "Backup timed out after 2 hours.\n", "stderr",
                )
                GLib.idle_add(self._bak_start_btn.set_sensitive, True)
                return
            except Exception as e:
                GLib.idle_add(
                    self._backup_output.append,
                    f"Error: {e}\n", "stderr",
                )
                GLib.idle_add(self._bak_start_btn.set_sensitive, True)
                return

            if out:
                GLib.idle_add(self._backup_output.append, out, "stdout")
            if rc == 0:
                GLib.idle_add(
                    self._backup_output.append,
                    "\nBackup completed successfully.\n", "success",
                )
                send_notification(
                    "Dom0 backup completed",
                    f"Saved to {dest}",
                    icon=NOTIFY_ICON_SUCCESS,
                )
                GLib.idle_add(self._refresh_backup_status)
            else:
                GLib.idle_add(
                    self._backup_output.append,
                    f"\nBackup failed (exit {rc}): {err}\n", "stderr",
                )
                send_notification(
                    "Dom0 backup failed",
                    err.strip()[:80] or f"Exit code {rc}",
                    icon=NOTIFY_ICON_ERROR, urgency="critical",
                )
            GLib.idle_add(self._bak_start_btn.set_sensitive, True)

        threading.Thread(target=_do, daemon=True).start()

    def _on_backup_service_config(self, _btn):
        bdir = self._svc_backup_dir.get_text().strip()
        if not bdir:
            show_error_dialog(self, "No Directory", "Enter a backup directory path.")
            return

        from datetime import datetime
        ts = datetime.now().strftime("%Y%m%d-%H%M%S")
        dest = os.path.join(bdir, f"qvm-remote-config-{ts}.tar.gz")

        self._backup_output.clear()
        self._backup_output.append(f"Backing up service config to {dest}...\n", "info")

        def _do():
            import tarfile
            try:
                Path(bdir).mkdir(parents=True, exist_ok=True)
                with tarfile.open(dest, "w:gz") as tar:
                    if CONF_FILE.exists():
                        tar.add(str(CONF_FILE), arcname="remote.conf")
                    if KEYS_DIR.exists():
                        tar.add(str(KEYS_DIR), arcname="remote.d")
                    if LOG_FILE.exists():
                        tar.add(str(LOG_FILE), arcname="qvm-remote.log")
                size = format_file_size(os.path.getsize(dest))
                GLib.idle_add(
                    self._backup_output.append,
                    f"Config backup saved: {dest} ({size})\n", "success",
                )
                GLib.idle_add(self._refresh_svc_backup_list)
                send_notification(
                    "Service config backed up",
                    f"Saved to {dest} ({size})",
                    icon=NOTIFY_ICON_BACKUP,
                )
            except Exception as e:
                GLib.idle_add(
                    self._backup_output.append,
                    f"Backup failed: {e}\n", "stderr",
                )
                send_notification(
                    "Config backup failed",
                    str(e),
                    icon=NOTIFY_ICON_ERROR, urgency="critical",
                )

        threading.Thread(target=_do, daemon=True).start()

    def _refresh_svc_backup_list(self):
        self._svc_restore_combo.remove_all()
        bdir = self._svc_backup_dir.get_text().strip()
        if not bdir:
            return
        backups = list_local_backups(bdir)
        for path, size, mtime in backups:
            label = f"{os.path.basename(path)} ({size}, {mtime})"
            self._svc_restore_combo.append(path, label)
        if backups:
            self._svc_restore_combo.set_active(0)

    def _on_restore_service_config(self, _btn):
        active_id = self._svc_restore_combo.get_active_id()
        if not active_id:
            show_error_dialog(
                self, "No Backup Selected",
                "Select a config backup archive from the list.",
            )
            return
        if not show_confirm_dialog(
            self,
            "Restore Service Configuration?",
            f"This will overwrite:\n"
            f"  - {CONF_FILE}\n"
            f"  - {KEYS_DIR}/ (all VM keys)\n\n"
            f"From: {os.path.basename(active_id)}\n\n"
            "The current config will be backed up first.\n"
            "The service should be restarted after restore.\n\n"
            "Are you sure?",
        ):
            return

        self._backup_output.clear()
        self._backup_output.append(
            f"Restoring config from {os.path.basename(active_id)}...\n", "info",
        )

        def _do():
            import tarfile
            from datetime import datetime
            # Safety backup
            ts = datetime.now().strftime("%Y%m%d-%H%M%S")
            bdir = self._svc_backup_dir.get_text().strip() or "/var/backups/qvm-remote"
            safety = os.path.join(bdir, f"qvm-remote-config-pre-restore-{ts}.tar.gz")
            try:
                Path(bdir).mkdir(parents=True, exist_ok=True)
                with tarfile.open(safety, "w:gz") as tar:
                    if CONF_FILE.exists():
                        tar.add(str(CONF_FILE), arcname="remote.conf")
                    if KEYS_DIR.exists():
                        tar.add(str(KEYS_DIR), arcname="remote.d")
                GLib.idle_add(
                    self._backup_output.append,
                    f"Safety backup: {safety}\n", "info",
                )
            except Exception as e:
                GLib.idle_add(
                    self._backup_output.append,
                    f"Warning: Could not create safety backup: {e}\n", "stderr",
                )

            try:
                with tarfile.open(active_id, "r:gz") as tar:
                    members = tar.getnames()
                    for m in members:
                        if m.startswith("/") or ".." in m:
                            GLib.idle_add(
                                self._backup_output.append,
                                f"Unsafe path in archive: {m}\n", "stderr",
                            )
                            return
                    # Extract remote.conf to /etc/qubes/
                    for member in tar.getmembers():
                        if member.name == "remote.conf":
                            member.name = str(CONF_FILE)
                            tar.extract(member, "/")
                        elif member.name.startswith("remote.d"):
                            member.name = str(KEYS_DIR.parent / member.name)
                            tar.extract(member, "/")
                GLib.idle_add(
                    self._backup_output.append,
                    "Service configuration restored. Restart the service to apply.\n",
                    "success",
                )
                send_notification(
                    "Service config restored",
                    "Restart the service to apply changes.",
                    icon=NOTIFY_ICON_BACKUP,
                )
            except Exception as e:
                GLib.idle_add(
                    self._backup_output.append,
                    f"Restore failed: {e}\n", "stderr",
                )
                send_notification(
                    "Config restore failed",
                    str(e),
                    icon=NOTIFY_ICON_ERROR, urgency="critical",
                )

        threading.Thread(target=_do, daemon=True).start()

    def _load_dom0_changes(self):
        """Load recent changes from the daemon log."""
        self._dom0_changes_view.clear()
        if not LOG_FILE.exists():
            self._dom0_changes_view.append("No log entries yet.\n", "info")
            return
        try:
            lines = LOG_FILE.read_text().splitlines()
            if not lines:
                self._dom0_changes_view.append("Log is empty.\n", "info")
                return
            self._dom0_changes_view.append(
                "--- Recent dom0 activity (newest first) ---\n", "info",
            )
            for line in reversed(lines[-30:]):
                tag = "stdout"
                lower = line.lower()
                if "error" in lower or "reject" in lower or "auth-fail" in lower:
                    tag = "stderr"
                elif "done" in lower:
                    tag = "success"
                elif "authorize" in lower or "revoke" in lower or "key" in lower:
                    tag = "info"
                self._dom0_changes_view.append(line + "\n", tag)
        except OSError as e:
            self._dom0_changes_view.append(f"Error reading log: {e}\n", "stderr")

    # ── Log tab ─────────────────────────────────────────────────────

    def _build_log_tab(self):
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)
        vbox.set_margin_start(10)
        vbox.set_margin_end(10)
        vbox.set_margin_top(10)
        vbox.set_margin_bottom(10)

        hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=8)

        self._log_search = Gtk.SearchEntry()
        self._log_search.set_placeholder_text("Search log...")
        self._log_search.connect("search-changed", self._on_log_search)
        hbox.pack_start(self._log_search, True, True, 0)

        lines_label = Gtk.Label(label="Lines:")
        hbox.pack_start(lines_label, False, False, 0)

        adj = Gtk.Adjustment(value=200, lower=10, upper=5000, step_increment=50)
        self._log_lines_spin = Gtk.SpinButton(adjustment=adj, climb_rate=1, digits=0)
        hbox.pack_start(self._log_lines_spin, False, False, 0)

        refresh_btn = Gtk.Button(label="Refresh")
        refresh_btn.connect("clicked", lambda b: self._load_log())
        hbox.pack_start(refresh_btn, False, False, 0)

        self._log_live = Gtk.CheckButton(label="Live tail")
        self._log_live.set_active(False)
        self._log_live.connect("toggled", self._on_log_live_toggle)
        hbox.pack_start(self._log_live, False, False, 0)

        vbox.pack_start(hbox, False, False, 0)

        self._log_output = OutputView()
        vbox.pack_start(self._log_output, True, True, 0)

        self._notebook.append_page(vbox, Gtk.Label(label="Log"))
        self._log_timer = None

    def _load_log(self):
        self._log_output.clear()
        if not LOG_FILE.exists():
            self._log_output.append("No log file found.\n", "info")
            self._log_output.append(
                f"Expected: {LOG_FILE}\n"
                "Start the service to create the log.\n",
                "info",
            )
            return
        try:
            lines = LOG_FILE.read_text().splitlines()
            n = int(self._log_lines_spin.get_value())
            query = self._log_search.get_text().lower()
            for line in lines[-n:]:
                if query and query not in line.lower():
                    continue
                tag = "stdout"
                lower = line.lower()
                if "error" in lower or "reject" in lower or "auth-fail" in lower:
                    tag = "stderr"
                elif "done" in lower:
                    tag = "success"
                elif "starting" in lower or "listening" in lower:
                    tag = "info"
                self._log_output.append(line + "\n", tag)
        except OSError as e:
            self._log_output.append(f"Error reading log: {e}\n", "stderr")

    def _on_log_search(self, _entry):
        self._load_log()

    def _on_log_live_toggle(self, btn):
        if btn.get_active():
            self._log_timer = GLib.timeout_add_seconds(3, self._log_live_tick)
        elif self._log_timer:
            GLib.source_remove(self._log_timer)
            self._log_timer = None

    def _log_live_tick(self):
        if self._log_live.get_active() and self._notebook.get_current_page() == 3:
            self._load_log()
        return self._log_live.get_active()

    # ── Tab switch ──────────────────────────────────────────────────

    def _on_tab_switch(self, notebook, page, page_num):
        if page_num == 0:
            self._refresh_dashboard()
        elif page_num == 1:
            self._load_vms()
        elif page_num == 2:
            self._refresh_backup_status()
            self._refresh_svc_backup_list()
            self._load_dom0_changes()
        elif page_num == 3:
            self._load_log()


# ── Application ─────────────────────────────────────────────────────


class QvmRemoteDom0App(Gtk.Application):
    def __init__(self):
        super().__init__(application_id=APP_ID)

    def do_activate(self):
        apply_css()
        win = QvmRemoteDom0Window(self)
        win.show_all()

    def do_startup(self):
        Gtk.Application.do_startup(self)


def main():
    app = QvmRemoteDom0App()
    return app.run(sys.argv)


if __name__ == "__main__":
    sys.exit(main())
