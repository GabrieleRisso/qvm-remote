#!/usr/bin/python3
# qvm-remote-dom0 -- dom0 executor daemon for qvm-remote
#
# Copyright (C) 2026  qvm-remote contributors
# SPDX-License-Identifier: GPL-2.0-or-later

"""Dom0 executor daemon for qvm-remote.

Polls authorized VMs for queued commands, verifies HMAC-SHA256
auth tokens, executes commands in dom0, and writes results back.
"""

from __future__ import annotations

import hashlib
import hmac as _hmac
import os
import signal
import subprocess
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import NoReturn

VERSION = "1.1.0"
PROGNAME = "qvm-remote-dom0"

CONF = Path("/etc/qubes/remote.conf")
KEYS_DIR = Path("/etc/qubes/remote.d")
LOG_FILE = Path("/var/log/qubes/qvm-remote.log")
DEFAULT_VM_USER = "user"
VM_DATA_DIR = f"/home/{DEFAULT_VM_USER}/.qvm-remote"
SERVICE = "qvm-remote-dom0"
MAX_OUTPUT = 10 << 20    # 10 MiB
MAX_CMD_SIZE = 1 << 20   # 1 MiB
EXEC_TIMEOUT = 300       # seconds per command (matches client default)

USAGE = """\
usage: qvm-remote-dom0 [--vm VM] [--once] [--dry-run]
       qvm-remote-dom0 authorize VM [KEY]
       qvm-remote-dom0 revoke VM
       qvm-remote-dom0 keys

Dom0 executor daemon for qvm-remote.  Polls authorized VMs for
commands, verifies HMAC-SHA256 auth tokens, executes in dom0.

daemon options:
  --vm VM              override VM list (single VM mode)
  --once               process pending commands once, then exit
  --dry-run            log commands without executing
  -v, --verbose        increase verbosity
  -h, --help           show this help
  --version            show version

key management:
  authorize VM [KEY]   authorize VM with 256-bit hex key (or stdin)
  revoke VM            revoke VM authorization
  keys                 list authorized VMs

connection management:
  connect VM [KEY]     authorize + add to config + init VM dirs
  disconnect VM        revoke + remove from config + clean VM queue
  status               show daemon state, connected VMs, queue health

queue management:
  queue status [VM]    show queue counts for all or one VM
  queue clean [VM]     remove stale entries from VM queues
  queue recover [VM]   fail stuck running commands (returns error to client)
  queue debug [VM]     detailed queue dump for troubleshooting

service:
  enable               enable autostart (interactive risk prompt)
  disable              disable autostart and stop

setup:
  # in VM:   qvm-remote key gen
  # in dom0: qvm-remote-dom0 authorize VMNAME <key>
  #          systemctl start qvm-remote-dom0
"""

_running = True


# ── helpers ──────────────────────────────────────────────────────────

def die(msg: str, code: int = 1) -> NoReturn:
    print(f"{PROGNAME}: {msg}", file=sys.stderr)
    sys.exit(code)


def require_root(action: str = "") -> None:
    """Exit with a clear message when not running as root."""
    if os.geteuid() != 0:
        hint = f" to {action}" if action else ""
        die(
            f"must run as root{hint}\n"
            f"  hint: sudo {PROGNAME} {' '.join(sys.argv[1:])}"
        )


def log(msg: str) -> None:
    ts = datetime.now().isoformat(timespec="seconds")
    line = f"[{ts}] {msg}"
    print(line, flush=True)
    try:
        with open(LOG_FILE, "a") as f:
            f.write(line + "\n")
    except OSError:
        pass


def hmac_token(key: str, cmd_id: str) -> str:
    """HMAC-SHA256(key, command_id)."""
    return _hmac.new(
        key.encode(), cmd_id.encode(), hashlib.sha256
    ).hexdigest()


def valid_hex_key(key: str) -> bool:
    if len(key) != 64:
        return False
    try:
        int(key, 16)
        return True
    except ValueError:
        return False


def load_config() -> dict[str, str]:
    """Parse /etc/qubes/remote.conf (bash-compatible key=value)."""
    config: dict[str, str] = {}
    if CONF.exists():
        for raw in CONF.read_text().splitlines():
            s = raw.strip()
            if not s or s.startswith("#"):
                continue
            if "=" in s:
                k, v = s.split("=", 1)
                config[k.strip()] = v.strip().strip('"').strip("'")
    return config


def resolve_vm_user() -> str:
    """Resolve the VM-side username: env > config > default ('user')."""
    v = os.environ.get("QVM_REMOTE_VM_USER", "")
    if v:
        return v
    config = load_config()
    return config.get("QVM_REMOTE_VM_USER", DEFAULT_VM_USER)


def vm_data_dir() -> str:
    """Return the VM-side data directory path."""
    return f"/home/{resolve_vm_user()}/.qvm-remote"


def get_vm_key(vm: str) -> str | None:
    kf = KEYS_DIR / f"{vm}.key"
    if not kf.exists():
        return None
    return kf.read_text().strip()


def resolve_vms(cli_vm: str | None) -> list[str]:
    """Resolve VM list: CLI > env (systemd EnvironmentFile) > config."""
    if cli_vm:
        return [cli_vm]
    for var in (
        "QVM_REMOTE_VMS", "QUBES_REMOTE_VMS",
        "QVM_REMOTE_VM", "QUBES_REMOTE_VM",
    ):
        v = os.environ.get(var, "")
        if v:
            return v.split()
    config = load_config()
    for var in (
        "QVM_REMOTE_VMS", "QUBES_REMOTE_VMS",
        "QVM_REMOTE_VM", "QUBES_REMOTE_VM",
    ):
        v = config.get(var, "")
        if v:
            return v.split()
    return []


def has_binary_content(data: bytes) -> bool:
    """Reject null bytes and most control characters."""
    for b in data:
        if b <= 0x08:
            return True
        if b in (0x0B, 0x0C):
            return True
        if 0x0E <= b <= 0x1F:
            return True
    return False


# ── VM communication ─────────────────────────────────────────────────
# Uses qvm-run --no-autostart: never start VMs as a side effect.

def vm_exec(vm: str, cmd: str) -> str:
    """Run command in VM, return stdout as text."""
    r = subprocess.run(
        ["qvm-run", "--no-gui", "--no-autostart", "--pass-io", vm, cmd],
        capture_output=True, text=True, timeout=30,
    )
    return r.stdout


def vm_exec_bytes(vm: str, cmd: str) -> bytes:
    """Run command in VM, return raw stdout."""
    r = subprocess.run(
        ["qvm-run", "--no-gui", "--no-autostart", "--pass-io", vm, cmd],
        capture_output=True, timeout=30,
    )
    return r.stdout


def vm_fire(vm: str, cmd: str) -> None:
    """Fire-and-forget command in VM."""
    try:
        subprocess.run(
            ["qvm-run", "--no-gui", "--no-autostart", vm, cmd],
            capture_output=True, timeout=10,
        )
    except Exception:
        pass


def vm_write(vm: str, path: str, data: bytes) -> None:
    """Write data to a file in VM via qvm-run --pass-io."""
    subprocess.run(
        [
            "qvm-run", "--no-gui", "--no-autostart", "--pass-io",
            vm, f"cat > '{path}'",
        ],
        input=data, capture_output=True, timeout=30,
    )


def init_vm_dirs(vm: str) -> None:
    vm_user = resolve_vm_user()
    old_dir = f"/home/{vm_user}/.qubes-remote"
    vm_fire(
        vm,
        f"[ -d {old_dir} ] && "
        f"[ ! -d {VM_DATA_DIR} ] && "
        f"mv {old_dir} {VM_DATA_DIR} 2>/dev/null; "
        f"mkdir -p {VM_DATA_DIR}/{{queue/{{pending,running,results}},history}}",
    )


def recover_stale_running(vm: str) -> None:
    """On daemon start, fail any commands left in running/ from a prior crash."""
    raw = vm_exec(
        vm, f"ls -1 {VM_DATA_DIR}/queue/running/ 2>/dev/null"
    )
    stale = [f.strip().replace("\r", "") for f in raw.splitlines() if f.strip()]
    for cmd_id in stale:
        log(f"RECOVER vm={vm} id={cmd_id} (stale from prior daemon run)")
        ts = datetime.now().isoformat(timespec="seconds")
        vm_write(
            vm, f"{VM_DATA_DIR}/queue/results/{cmd_id}.out", b""
        )
        vm_write(
            vm, f"{VM_DATA_DIR}/queue/results/{cmd_id}.err",
            b"qvm-remote-dom0: command interrupted (daemon restarted)\n",
        )
        vm_write(
            vm, f"{VM_DATA_DIR}/queue/results/{cmd_id}.exit", b"130"
        )
        meta = (
            f"id={cmd_id}\nstarted=unknown\n"
            f"duration_ms=0\nexit_code=130\n"
            f"recovered={ts}\n"
        ).encode()
        vm_write(vm, f"{VM_DATA_DIR}/queue/results/{cmd_id}.meta", meta)
        vm_fire(vm, f"rm -f '{VM_DATA_DIR}/queue/running/{cmd_id}'")


def list_pending(vm: str) -> list[str]:
    raw = vm_exec(
        vm, f"ls -1 {VM_DATA_DIR}/queue/pending/ 2>/dev/null"
    )
    return [
        f.strip().replace("\r", "")
        for f in raw.splitlines()
        if f.strip() and not f.strip().endswith((".auth", ".cmd"))
    ]


# ── key management ───────────────────────────────────────────────────

def cmd_authorize(args: list[str]) -> int:
    require_root("authorize a VM")
    if not args:
        die("usage: authorize VM [KEY]")
    vm = args[0]
    if len(args) > 1:
        key = args[1]
    else:
        print(f"Enter 256-bit hex key for '{vm}':")
        key = input()
    key = key.strip()
    if not valid_hex_key(key):
        die("invalid key (expected 64 hex characters)")
    try:
        KEYS_DIR.mkdir(parents=True, exist_ok=True)
        KEYS_DIR.chmod(0o700)
        kf = KEYS_DIR / f"{vm}.key"
        kf.write_text(key)
        kf.chmod(0o600)
    except OSError as e:
        die(f"failed to store key: {e}")
    print(f"Authorized VM '{vm}'. Key stored in {kf}")
    print(f"\nEnsure VM is listed in {CONF}:")
    print(f'  QVM_REMOTE_VMS="{vm}"')
    return 0


def cmd_revoke(args: list[str]) -> int:
    require_root("revoke a VM")
    if not args:
        die("usage: revoke VM")
    vm = args[0]
    kf = KEYS_DIR / f"{vm}.key"
    if kf.exists():
        kf.unlink()
        print(f"Revoked VM '{vm}'.")
        return 0
    die(f"VM '{vm}' has no key")


def cmd_keys() -> int:
    if not KEYS_DIR.exists() or not any(KEYS_DIR.glob("*.key")):
        print("No VMs authorized.")
        return 0
    print(f"{'VM':<20} KEY (first 16 chars)")
    print(f"{'---':<20} ---")
    for kf in sorted(KEYS_DIR.glob("*.key")):
        preview = kf.read_text()[:16] + "..."
        print(f"{kf.stem:<20} {preview}")
    return 0


# ── service management ───────────────────────────────────────────────

def cmd_enable() -> int:
    require_root("enable the service")
    print()
    print("WARNING: Enabling autostart for qvm-remote-dom0.")
    print()
    print("This will automatically start on every boot, granting authorized")
    print("VMs the ability to execute arbitrary commands in dom0 with full")
    print("root privileges.")
    print()
    print("A compromise of any authorized VM would give an attacker")
    print("complete control over dom0 and every other VM on this system.")
    print()
    answer = input("Type 'yes' to accept this risk and enable: ")
    if answer != "yes":
        print("Aborted.")
        return 1
    r1 = subprocess.run(
        ["systemctl", "enable", SERVICE],
        capture_output=True, text=True, timeout=30,
    )
    if r1.returncode != 0:
        die(f"systemctl enable failed: {r1.stderr.strip()}")
    r2 = subprocess.run(
        ["systemctl", "start", SERVICE],
        capture_output=True, text=True, timeout=30,
    )
    if r2.returncode != 0:
        die(f"systemctl start failed: {r2.stderr.strip()}")
    print(f"\nEnabled and started. Disable with: {PROGNAME} disable")
    return 0


def cmd_disable() -> int:
    require_root("disable the service")
    r1 = subprocess.run(
        ["systemctl", "disable", SERVICE],
        capture_output=True, text=True, timeout=30,
    )
    r2 = subprocess.run(
        ["systemctl", "stop", SERVICE],
        capture_output=True, text=True, timeout=30,
    )
    if r1.returncode != 0 or r2.returncode != 0:
        err = (r1.stderr.strip() + " " + r2.stderr.strip()).strip()
        die(f"systemctl failed: {err}")
    print("Disabled and stopped.")
    return 0


# ── connection management ────────────────────────────────────────────

def _read_conf_vms() -> list[str]:
    """Read the current QVM_REMOTE_VMS list from config file."""
    if not CONF.exists():
        return []
    for raw in CONF.read_text().splitlines():
        s = raw.strip()
        if s.startswith("QVM_REMOTE_VMS="):
            val = s.split("=", 1)[1].strip().strip('"').strip("'")
            return val.split() if val else []
    return []


def _write_conf_vms(vms: list[str]) -> None:
    """Update QVM_REMOTE_VMS in config file, preserving other lines."""
    new_line = f'QVM_REMOTE_VMS="{" ".join(vms)}"'
    if CONF.exists():
        lines = CONF.read_text().splitlines()
        replaced = False
        for i, raw in enumerate(lines):
            if raw.strip().startswith("QVM_REMOTE_VMS=") or \
               raw.strip().startswith("#QVM_REMOTE_VMS="):
                lines[i] = new_line
                replaced = True
                break
        if not replaced:
            lines.append(new_line)
        CONF.write_text("\n".join(lines) + "\n")
    else:
        CONF.parent.mkdir(parents=True, exist_ok=True)
        CONF.write_text(new_line + "\n")


def cmd_connect(args: list[str]) -> int:
    """Full connection setup: authorize key + add to config + init VM dirs."""
    require_root("connect a VM")
    if not args:
        die("usage: connect VM [KEY]")
    vm = args[0]

    r = subprocess.run(["qvm-check", vm], capture_output=True, timeout=10)
    if r.returncode != 0:
        die(f"VM '{vm}' does not exist")

    r = subprocess.run(
        ["qvm-check", vm, "--running"],
        capture_output=True, timeout=10,
    )
    if r.returncode != 0:
        die(f"VM '{vm}' is not running (start it first: qvm-start {vm})")

    if len(args) > 1:
        key = args[1].strip()
    else:
        print(f"Fetching key from VM '{vm}'...")
        try:
            data_path = vm_data_dir()
            raw = vm_exec(vm, f"cat {data_path}/auth.key 2>/dev/null")
            key = raw.strip()
        except Exception:
            key = ""
        if not key:
            die(
                f"could not fetch key from '{vm}'\n"
                f"  hint: in the VM run: qvm-remote key gen\n"
                f"  then: qvm-remote-dom0 connect {vm} <KEY>"
            )

    if not valid_hex_key(key):
        die("invalid key (expected 64 hex characters)")

    try:
        KEYS_DIR.mkdir(parents=True, exist_ok=True)
        KEYS_DIR.chmod(0o700)
        kf = KEYS_DIR / f"{vm}.key"
        kf.write_text(key)
        kf.chmod(0o600)
    except OSError as e:
        die(f"failed to store key: {e}")

    conf_vms = _read_conf_vms()
    if vm not in conf_vms:
        conf_vms.append(vm)
        _write_conf_vms(conf_vms)

    data_path = vm_data_dir()
    vm_fire(
        vm,
        f"mkdir -p {data_path}/{{queue/{{pending,running,results}},history}}",
    )

    print(f"Connected VM '{vm}'.")
    print(f"  Key:    {key[:16]}...")
    print(f"  Config: {CONF}")
    print(f"  VMs:    {' '.join(conf_vms)}")

    svc = subprocess.run(
        ["systemctl", "is-active", SERVICE],
        capture_output=True, text=True, timeout=5,
    )
    if svc.stdout.strip() != "active":
        print(f"\n  Daemon is not running. Start it:")
        print(f"    systemctl restart {SERVICE}")
    else:
        print(f"\n  Daemon is running. Restart to pick up new VM:")
        print(f"    systemctl restart {SERVICE}")

    log(f"CONNECT vm={vm}")
    return 0


def cmd_disconnect(args: list[str]) -> int:
    """Disconnect a VM: revoke key + remove from config + clean queue."""
    require_root("disconnect a VM")
    if not args:
        die("usage: disconnect VM")
    vm = args[0]

    kf = KEYS_DIR / f"{vm}.key"
    if kf.exists():
        kf.unlink()

    conf_vms = _read_conf_vms()
    if vm in conf_vms:
        conf_vms.remove(vm)
        _write_conf_vms(conf_vms)

    try:
        data_path = vm_data_dir()
        r = subprocess.run(
            ["qvm-check", vm, "--running"],
            capture_output=True, timeout=5,
        )
        if r.returncode == 0:
            cleaned = 0
            for subdir in ("pending", "running", "results"):
                raw = vm_exec(
                    vm, f"ls -1 {data_path}/queue/{subdir}/ 2>/dev/null | wc -l"
                )
                cleaned += int(raw.strip() or "0")
            vm_fire(vm, f"rm -rf {data_path}/queue/{{pending,running,results}}/*")
            print(f"Cleaned {cleaned} queue file(s) in VM '{vm}'.")
    except Exception:
        pass

    print(f"Disconnected VM '{vm}'.")
    print(f"  Key revoked, removed from config.")
    if conf_vms:
        print(f"  Remaining VMs: {' '.join(conf_vms)}")
    else:
        print(f"  No VMs remaining in config.")

    svc = subprocess.run(
        ["systemctl", "is-active", SERVICE],
        capture_output=True, text=True, timeout=5,
    )
    if svc.stdout.strip() == "active":
        print(f"\n  Restart daemon to stop polling disconnected VM:")
        print(f"    systemctl restart {SERVICE}")

    log(f"DISCONNECT vm={vm}")
    return 0


def cmd_status_report() -> int:
    """Full daemon status report: service, config, VMs, keys, queue health."""
    svc = subprocess.run(
        ["systemctl", "is-active", SERVICE],
        capture_output=True, text=True, timeout=5,
    )
    active = svc.stdout.strip() == "active"
    en = subprocess.run(
        ["systemctl", "is-enabled", SERVICE],
        capture_output=True, text=True, timeout=5,
    )
    enabled = en.stdout.strip() == "enabled"

    print(f"qvm-remote-dom0 {VERSION}")
    print(f"  Service:   {'running' if active else 'STOPPED'}")
    print(f"  Autostart: {'enabled' if enabled else 'disabled'}")
    print(f"  Config:    {CONF}")
    print(f"  Keys dir:  {KEYS_DIR}")
    print(f"  Log:       {LOG_FILE}")

    conf_vms = _read_conf_vms()
    key_vms = []
    if KEYS_DIR.exists():
        key_vms = [kf.stem for kf in sorted(KEYS_DIR.glob("*.key"))]

    print(f"\nConfigured VMs: {' '.join(conf_vms) if conf_vms else '(none)'}")
    print(f"Authorized VMs: {' '.join(key_vms) if key_vms else '(none)'}")

    mismatched = set(conf_vms) - set(key_vms)
    if mismatched:
        print(f"\n  WARNING: VMs in config but no key: {' '.join(mismatched)}")
        print(f"  These VMs will have AUTH-DENY errors.")

    orphan_keys = set(key_vms) - set(conf_vms)
    if orphan_keys:
        print(f"\n  INFO: VMs with keys but not in config: {' '.join(orphan_keys)}")
        print(f"  These VMs are authorized but won't be polled.")

    data_path = vm_data_dir()
    for vm in conf_vms:
        r = subprocess.run(
            ["qvm-check", vm, "--running"],
            capture_output=True, timeout=5,
        )
        running = r.returncode == 0
        has_key = vm in key_vms
        status_parts = []
        if running:
            status_parts.append("running")
        else:
            status_parts.append("STOPPED")
        if has_key:
            status_parts.append("key-ok")
        else:
            status_parts.append("NO-KEY")

        q_info = ""
        if running:
            try:
                raw = vm_exec(
                    vm,
                    f"echo -n P=$(ls -1 {data_path}/queue/pending/ 2>/dev/null "
                    f"| grep -cv '^$' || echo 0)' '"
                    f"R=$(ls -1 {data_path}/queue/running/ 2>/dev/null "
                    f"| grep -cv '^$' || echo 0)' '"
                    f"D=$(ls -1 {data_path}/queue/results/ 2>/dev/null "
                    f"| grep -cv '^$' || echo 0)",
                )
                q_info = f"  queue=[{raw.strip()}]"
            except Exception:
                q_info = "  queue=[error]"

        print(f"  {vm:<20} {', '.join(status_parts)}{q_info}")

    return 0


def cmd_queue_op(args: list[str]) -> int:
    """Queue management: status, clean, recover, debug."""
    if not args:
        args = ["status"]
    action = args[0]
    target_vm = args[1] if len(args) > 1 else None

    conf_vms = _read_conf_vms()
    if target_vm:
        vms = [target_vm]
    elif conf_vms:
        vms = conf_vms
    else:
        die("no VMs configured")

    data_path = vm_data_dir()

    if action == "status":
        print(f"{'VM':<20} {'Pending':>8} {'Running':>8} {'Results':>8}")
        print(f"{'─'*20} {'─'*8} {'─'*8} {'─'*8}")
        for vm in vms:
            r = subprocess.run(
                ["qvm-check", vm, "--running"],
                capture_output=True, timeout=5,
            )
            if r.returncode != 0:
                print(f"{vm:<20} {'(not running)':>26}")
                continue
            try:
                counts = {}
                for subdir in ("pending", "running", "results"):
                    raw = vm_exec(
                        vm,
                        f"ls -1 {data_path}/queue/{subdir}/ 2>/dev/null "
                        f"| grep -cv '^$' || echo 0",
                    )
                    counts[subdir] = raw.strip()
                print(f"{vm:<20} {counts['pending']:>8} "
                      f"{counts['running']:>8} {counts['results']:>8}")
            except Exception:
                print(f"{vm:<20} {'(error)':>26}")
        return 0

    if action == "clean":
        for vm in vms:
            r = subprocess.run(
                ["qvm-check", vm, "--running"],
                capture_output=True, timeout=5,
            )
            if r.returncode != 0:
                print(f"{vm}: not running, skipped")
                continue
            raw = vm_exec(
                vm,
                f"find {data_path}/queue/ -type f 2>/dev/null | wc -l",
            )
            before = int(raw.strip() or "0")
            vm_fire(
                vm,
                f"rm -rf {data_path}/queue/{{pending,running,results}}/* && "
                f"mkdir -p {data_path}/queue/{{pending,running,results}}",
            )
            print(f"{vm}: cleaned {before} file(s)")
            log(f"QUEUE-CLEAN vm={vm} removed={before}")
        return 0

    if action == "recover":
        for vm in vms:
            r = subprocess.run(
                ["qvm-check", vm, "--running"],
                capture_output=True, timeout=5,
            )
            if r.returncode != 0:
                print(f"{vm}: not running, skipped")
                continue
            raw = vm_exec(
                vm, f"ls -1 {data_path}/queue/running/ 2>/dev/null"
            )
            stale = [
                f.strip().replace("\r", "")
                for f in raw.splitlines() if f.strip()
            ]
            if not stale:
                print(f"{vm}: no stale running commands")
                continue
            for cmd_id in stale:
                ts = datetime.now().isoformat(timespec="seconds")
                vm_write(
                    vm, f"{data_path}/queue/results/{cmd_id}.out", b""
                )
                vm_write(
                    vm, f"{data_path}/queue/results/{cmd_id}.err",
                    b"qvm-remote-dom0: command recovered (manual queue recover)\n",
                )
                vm_write(
                    vm, f"{data_path}/queue/results/{cmd_id}.exit", b"130"
                )
                meta = (
                    f"id={cmd_id}\nstarted=unknown\n"
                    f"duration_ms=0\nexit_code=130\n"
                    f"recovered={ts}\n"
                ).encode()
                vm_write(
                    vm, f"{data_path}/queue/results/{cmd_id}.meta", meta
                )
                vm_fire(vm, f"rm -f '{data_path}/queue/running/{cmd_id}'")
            print(f"{vm}: recovered {len(stale)} stale command(s)")
            log(f"QUEUE-RECOVER vm={vm} count={len(stale)}")
        return 0

    if action == "debug":
        for vm in vms:
            print(f"\n{'═'*60}")
            print(f"VM: {vm}")
            print(f"{'═'*60}")
            r = subprocess.run(
                ["qvm-check", vm, "--running"],
                capture_output=True, timeout=5,
            )
            if r.returncode != 0:
                print("  (not running)")
                continue
            for subdir in ("pending", "running", "results"):
                raw = vm_exec(
                    vm,
                    f"ls -la {data_path}/queue/{subdir}/ 2>/dev/null "
                    f"|| echo '  (empty)'",
                )
                print(f"\n── {subdir}/ ──")
                print(raw.rstrip())
            raw = vm_exec(
                vm,
                f"tail -5 {data_path}/audit.log 2>/dev/null "
                f"|| echo '  (no audit log)'",
            )
            print(f"\n── audit.log (last 5) ──")
            print(raw.rstrip())
        return 0

    die(f"unknown queue action: {action}")


# ── process one command ──────────────────────────────────────────────

def process(vm: str, cmd_id: str, *, dry_run: bool = False) -> bool:
    started = datetime.now().isoformat(timespec="seconds")
    t0 = time.monotonic_ns()

    log(f"EXEC vm={vm} id={cmd_id}")

    # fetch command as raw bytes
    try:
        script_bytes = vm_exec_bytes(
            vm, f"cat '{VM_DATA_DIR}/queue/pending/{cmd_id}'"
        )
    except Exception:
        log(f"ERROR vm={vm} id={cmd_id} fetch-failed")
        return False

    # ── validation (before execution) ───────────────────────────
    def reject(reason: str) -> bool:
        log(f"REJECT vm={vm} id={cmd_id} {reason}")
        vm_fire(
            vm,
            f"rm -f '{VM_DATA_DIR}/queue/pending/{cmd_id}' "
            f"'{VM_DATA_DIR}/queue/pending/{cmd_id}.auth' "
            f"'{VM_DATA_DIR}/queue/pending/{cmd_id}.cmd'",
        )
        return False

    if len(script_bytes) == 0:
        return reject("empty-command")
    if len(script_bytes) > MAX_CMD_SIZE:
        return reject(f"oversized ({len(script_bytes)} bytes)")
    if has_binary_content(script_bytes):
        return reject("binary-content")

    # ── HMAC verification ────────────────────────────────────────
    def auth_reject(reason: str, write_error: bool = False) -> bool:
        """Reject with full cleanup and optional error result for the client."""
        log(f"{reason} vm={vm} id={cmd_id}")
        if write_error:
            vm_write(
                vm, f"{VM_DATA_DIR}/queue/results/{cmd_id}.out", b""
            )
            vm_write(
                vm, f"{VM_DATA_DIR}/queue/results/{cmd_id}.err",
                f"qvm-remote-dom0: {reason.lower()} for id={cmd_id}\n".encode(),
            )
            vm_write(
                vm, f"{VM_DATA_DIR}/queue/results/{cmd_id}.exit", b"126"
            )
            ts = datetime.now().isoformat(timespec="seconds")
            meta = (
                f"id={cmd_id}\nstarted={ts}\n"
                f"duration_ms=0\nexit_code=126\n"
                f"error={reason}\n"
            ).encode()
            vm_write(
                vm, f"{VM_DATA_DIR}/queue/results/{cmd_id}.meta", meta
            )
        vm_fire(
            vm,
            f"rm -f '{VM_DATA_DIR}/queue/pending/{cmd_id}' "
            f"'{VM_DATA_DIR}/queue/pending/{cmd_id}.auth' "
            f"'{VM_DATA_DIR}/queue/pending/{cmd_id}.cmd'",
        )
        return False

    vm_key = get_vm_key(vm)
    if vm_key:
        vm_token = vm_exec(
            vm,
            f"cat '{VM_DATA_DIR}/queue/pending/{cmd_id}.auth' "
            f"2>/dev/null",
        ).strip()
        expected = hmac_token(vm_key, cmd_id)
        if not vm_token:
            return auth_reject("AUTH-FAIL-NO-TOKEN", write_error=True)
        if not _hmac.compare_digest(vm_token, expected):
            return auth_reject("AUTH-FAIL-BAD-TOKEN", write_error=True)
        vm_fire(
            vm,
            f"rm -f '{VM_DATA_DIR}/queue/pending/{cmd_id}.auth'",
        )
        log(f"AUTH-OK vm={vm} id={cmd_id}")
    else:
        if KEYS_DIR.exists() and any(KEYS_DIR.glob("*.key")):
            return auth_reject("AUTH-DENY", write_error=True)

    preview = (
        script_bytes[:200].decode(errors="replace").replace("\n", " ")
    )
    log(f"CMD vm={vm} id={cmd_id} cmd={preview}")

    # move to running
    vm_fire(
        vm,
        f"mv '{VM_DATA_DIR}/queue/pending/{cmd_id}' "
        f"'{VM_DATA_DIR}/queue/running/{cmd_id}'",
    )

    # ── execute (pipe directly to bash, no temp file) ────────────
    if dry_run:
        log(f"DRY vm={vm} id={cmd_id} skipped")
        out_data = f"[dry-run] {preview}\n".encode()
        err_data = b""
        rc = 0
    else:
        try:
            r = subprocess.run(
                ["bash"], input=script_bytes, capture_output=True,
                timeout=EXEC_TIMEOUT,
            )
            out_data = r.stdout
            err_data = r.stderr
            rc = r.returncode
        except subprocess.TimeoutExpired:
            log(f"TIMEOUT vm={vm} id={cmd_id} after={EXEC_TIMEOUT}s")
            out_data = b""
            err_data = (
                f"qvm-remote-dom0: command timed out "
                f"after {EXEC_TIMEOUT}s\n"
            ).encode()
            rc = 124

    t1 = time.monotonic_ns()
    ms = (t1 - t0) // 1_000_000

    # truncate oversized output
    if len(out_data) > MAX_OUTPUT:
        log(f"TRUNC vm={vm} id={cmd_id} stdout ({len(out_data)} bytes)")
        out_data = (
            out_data[:MAX_OUTPUT]
            + f"\n[truncated at {MAX_OUTPUT} bytes]\n".encode()
        )
    if len(err_data) > MAX_OUTPUT:
        log(f"TRUNC vm={vm} id={cmd_id} stderr ({len(err_data)} bytes)")
        err_data = (
            err_data[:MAX_OUTPUT]
            + f"\n[truncated at {MAX_OUTPUT} bytes]\n".encode()
        )

    # write results to VM
    vm_write(
        vm, f"{VM_DATA_DIR}/queue/results/{cmd_id}.out", out_data
    )
    vm_write(
        vm, f"{VM_DATA_DIR}/queue/results/{cmd_id}.err", err_data
    )
    vm_write(
        vm, f"{VM_DATA_DIR}/queue/results/{cmd_id}.exit",
        str(rc).encode(),
    )
    meta = (
        f"id={cmd_id}\nstarted={started}\n"
        f"duration_ms={ms}\nexit_code={rc}\n"
    ).encode()
    vm_write(vm, f"{VM_DATA_DIR}/queue/results/{cmd_id}.meta", meta)

    # clear running marker
    vm_fire(vm, f"rm -f '{VM_DATA_DIR}/queue/running/{cmd_id}'")

    # VM-side audit log
    audit_entry = (
        f"[{started}] id={cmd_id} exit={rc} "
        f"duration={ms}ms cmd={preview}\n"
    ).encode()
    vm_write(vm, f"{VM_DATA_DIR}/audit.log.tmp", audit_entry)
    vm_fire(
        vm,
        f"cat '{VM_DATA_DIR}/audit.log.tmp' >> '{VM_DATA_DIR}/audit.log' "
        f"&& rm -f '{VM_DATA_DIR}/audit.log.tmp'",
    )

    log(f"DONE vm={vm} id={cmd_id} exit={rc} duration={ms}ms")
    return True


# ── signal handling ──────────────────────────────────────────────────

def _on_signal(signum: int, frame: object) -> None:
    global _running
    _running = False


# ── main ─────────────────────────────────────────────────────────────

def main() -> int:
    global _running

    cli_vm: str | None = None
    run_once = False
    dry_run = False
    verbose = False
    rest: list[str] = []

    args = sys.argv[1:]
    i = 0
    while i < len(args):
        a = args[i]
        if a in ("-h", "--help"):
            print(USAGE, end="")
            return 0
        if a == "--version":
            print(f"{PROGNAME} {VERSION}")
            return 0
        if a == "--vm":
            if i + 1 >= len(args):
                die("--vm requires a value")
            cli_vm = args[i + 1]
            i += 2
            continue
        if a == "--once":
            run_once = True
        elif a == "--dry-run":
            dry_run = True
        elif a in ("-v", "--verbose"):
            verbose = True
        elif a.startswith("-"):
            die(f"unknown option: {a}")
        else:
            rest = args[i:]
            break
        i += 1

    # dispatch subcommands
    if rest:
        sub = rest[0]
        if sub == "authorize":
            return cmd_authorize(rest[1:])
        if sub == "revoke":
            return cmd_revoke(rest[1:])
        if sub == "keys":
            return cmd_keys()
        if sub == "connect":
            return cmd_connect(rest[1:])
        if sub == "disconnect":
            return cmd_disconnect(rest[1:])
        if sub == "status":
            return cmd_status_report()
        if sub == "queue":
            return cmd_queue_op(rest[1:])
        if sub == "enable":
            return cmd_enable()
        if sub == "disable":
            return cmd_disable()
        die(f"unknown command: {sub}")

    # ── daemon mode ──────────────────────────────────────────────
    require_root("run the daemon")
    global VM_DATA_DIR  # noqa: PLW0603
    VM_DATA_DIR = vm_data_dir()

    vms = resolve_vms(cli_vm)
    if not vms:
        die(
            f"no VMs configured. "
            f"Set QVM_REMOTE_VMS in {CONF} or use --vm VM"
        )

    for vm in vms:
        r = subprocess.run(["qvm-check", vm], capture_output=True)
        if r.returncode != 0:
            die(f"VM '{vm}' does not exist")

    LOG_FILE.parent.mkdir(parents=True, exist_ok=True)

    signal.signal(signal.SIGINT, _on_signal)
    signal.signal(signal.SIGTERM, _on_signal)

    log(f"{PROGNAME} {VERSION} starting (pid={os.getpid()}) vms={vms}")
    for vm in vms:
        init_vm_dirs(vm)
        recover_stale_running(vm)
    log(f"Listening for commands from: {' '.join(vms)}")

    while _running:
        for vm in vms:
            if not _running:
                break
            try:
                pending = list_pending(vm)
            except Exception:
                pending = []
            for cmd_id in pending:
                if not _running:
                    break
                try:
                    process(vm, cmd_id, dry_run=dry_run)
                except Exception as e:
                    log(f"ERROR vm={vm} id={cmd_id} {e}")
        if run_once:
            log("Single-run mode, exiting.")
            break
        time.sleep(1)

    log(f"Shutting down (pid={os.getpid()})")
    return 0


if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        sys.exit(130)
    except PermissionError as e:
        print(
            f"{PROGNAME}: permission denied: {e}\n"
            f"  hint: this command must run as root in dom0",
            file=sys.stderr,
        )
        sys.exit(1)
    except BrokenPipeError:
        sys.exit(141)
