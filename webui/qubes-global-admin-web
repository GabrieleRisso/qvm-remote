#!/usr/bin/python3
# qubes-global-admin-web -- Air-gapped web admin for Qubes OS
# Copyright (C) 2026  qvm-remote contributors
# SPDX-License-Identifier: GPL-2.0-or-later

"""Local web admin tool served on 127.0.0.1 in dom0.

Zero external dependencies -- uses only Python stdlib.
Serves a single-page app with:
  - Dashboard: daemon status, service control
  - Execute: run commands in dom0 via qvm-remote
  - Virtual Machines: authorize/revoke keys, start/stop VMs
  - Files: push/pull between dom0 and VMs
  - Backup: system + config backups
  - Log: daemon log viewer
  - This Device: system info
  - OpenClaw: manage multi-agent OpenClaw containers

All API calls are localhost-only. No internet connectivity required.
"""

import http.server
import json
import os
import re
import signal
import socketserver
import subprocess
import sys
import threading
import time
import urllib.parse
from pathlib import Path

VERSION = "1.1.0"
for d in [os.path.join(os.path.dirname(os.path.abspath(__file__)), ".."),
          os.path.dirname(os.path.abspath(__file__)), "/usr/lib/qvm-remote"]:
    vf = os.path.join(d, "version")
    if os.path.isfile(vf):
        try:
            VERSION = open(vf).read().strip()
        except OSError:
            pass
        break

HOST = "127.0.0.1"
PORT = int(os.environ.get("QUBES_ADMIN_PORT", "9876"))
CONF_FILE = "/etc/qubes/remote.conf"
KEY_DIR = "/etc/qubes/remote.d"
LOG_FILE = "/var/log/qubes/qvm-remote.log"

# Detect managed VM from config
def _get_managed_vm():
    try:
        for line in open(CONF_FILE).readlines():
            line = line.strip()
            if line.startswith("QVM_REMOTE_VMS="):
                vms = line.split("=", 1)[1].strip().strip('"').strip("'")
                return vms.split()[0] if vms else "unknown"
    except OSError:
        pass
    return "unknown"

MANAGED_VM = _get_managed_vm()
POLICY_FILE = "/etc/qubes/remote-admin-policy.json"
OPENCLAW_CONF = "/etc/qubes/openclaw.json"

_vm_list_cache = {"data": None, "ts": 0}


def _sd_notify(msg):
    """Send a systemd notification (READY=1 or WATCHDOG=1)."""
    addr = os.environ.get("NOTIFY_SOCKET")
    if not addr:
        return
    import socket as _sock
    try:
        s = _sock.socket(_sock.AF_UNIX, _sock.SOCK_DGRAM)
        if addr.startswith("@"):
            addr = "\0" + addr[1:]
        s.sendto(msg.encode(), addr)
        s.close()
    except Exception:
        pass


def run(cmd, timeout=30, shell=False):
    try:
        r = subprocess.run(cmd, capture_output=True, text=True,
                           timeout=timeout, shell=shell)
        return {"rc": r.returncode, "out": r.stdout, "err": r.stderr}
    except subprocess.TimeoutExpired:
        return {"rc": 124, "out": "", "err": "Command timed out"}
    except Exception as e:
        return {"rc": 1, "out": "", "err": str(e)}


# ── Policy enforcement engine ────────────────────────────────────
#
# Permission levels (cumulative):
#   deny    — blocked entirely
#   monitor — read-only: status, list, log, check
#   manage  — + start/stop, prefs, features, tags, services, firewall
#   full    — + execute, file transfer, backup, device attach, remove
#
# Default policy: dom0 = deny (no modifications), all other VMs = monitor.
# Specific VMs can be granted higher permissions via the policy file.
# The "dom0" scope covers direct command execution and dom0 system changes.
# The "global" scope covers qubes-prefs, dom0-update, policies, xen.

PERM_LEVELS = {"deny": 0, "monitor": 1, "manage": 2, "full": 3}

DEFAULT_POLICY = {
    "dom0": "deny",
    "default": "monitor",
    "vms": {},
    "dom0_read_allowed": True,
    "blocked_commands": [
        "rm -rf /", "dd if=", "mkfs", ":(){:|:&};:",
        "qvm-remove", "qvm-kill --all",
        "systemctl restart sys-usb", "systemctl stop sys-usb",
        "qvm-kill sys-net", "qvm-kill sys-firewall",
        "qvm-kill sys-usb", "qvm-remove dom0",
        "xl destroy", "cat > /usr/bin", "cat > /etc/systemd",
        "> /usr/bin/", "> /usr/local/bin/",
    ],
}


def _load_policy():
    try:
        with open(POLICY_FILE) as f:
            p = json.loads(f.read())
        for k in DEFAULT_POLICY:
            if k not in p:
                p[k] = DEFAULT_POLICY[k]
        return p
    except (OSError, json.JSONDecodeError):
        return dict(DEFAULT_POLICY)


def _save_policy(policy):
    try:
        os.makedirs(os.path.dirname(POLICY_FILE), exist_ok=True)
        with open(POLICY_FILE, "w") as f:
            json.dump(policy, f, indent=2)
        os.chmod(POLICY_FILE, 0o600)
        return True
    except OSError as e:
        return False


def _get_vm_perm(vm, policy=None):
    """Get the permission level for a VM."""
    if policy is None:
        policy = _load_policy()
    if vm == "dom0" or vm == "":
        return policy.get("dom0", "deny")
    if vm in policy.get("vms", {}):
        return policy["vms"][vm]
    return policy.get("default", "monitor")


def _perm_value(level):
    return PERM_LEVELS.get(level, 0)


def _check_perm(vm, required_level, policy=None):
    """Check if operation is allowed. Returns (allowed, error_msg)."""
    if policy is None:
        policy = _load_policy()
    actual = _get_vm_perm(vm, policy)
    if _perm_value(actual) >= _perm_value(required_level):
        return True, ""
    return False, "Policy denied: VM '{}' has '{}' permission, '{}' required".format(
        vm or "dom0", actual, required_level)


def _check_cmd_blocked(cmd, policy=None):
    """Check if a command matches any blocked pattern."""
    if policy is None:
        policy = _load_policy()
    for pattern in policy.get("blocked_commands", []):
        if pattern in cmd:
            return True, "Blocked command pattern: " + pattern
    return False, ""


def _check_dom0_write(policy=None):
    """Check if dom0 modifications are allowed."""
    if policy is None:
        policy = _load_policy()
    dom0_perm = policy.get("dom0", "deny")
    return _perm_value(dom0_perm) >= _perm_value("manage")


def _check_dom0_read(policy=None):
    """Check if dom0 read operations are allowed."""
    if policy is None:
        policy = _load_policy()
    if policy.get("dom0_read_allowed", True):
        return True
    return _perm_value(policy.get("dom0", "deny")) >= _perm_value("monitor")


def _policy_error(msg):
    return {"rc": 403, "out": "", "err": msg, "policy_denied": True}


# ── API handlers ─────────────────────────────────────────────────

def api_health(_params):
    """Lightweight health check for genmon/tray polling (fast, no heavy calls)."""
    daemon = run(["systemctl", "is-active", "qvm-remote-dom0"], timeout=3)
    web = "active"  # we're running
    vm = run(["qvm-check", MANAGED_VM, "--running"], timeout=3)
    return {
        "daemon": daemon["out"].strip() == "active",
        "web": True,
        "vm": vm["rc"] == 0,
        "vm_name": MANAGED_VM,
        "ts": int(time.time()),
    }


def api_self_heal(params):
    """Detect and fix broken services. Returns actions taken."""
    if not _check_dom0_write():
        return _policy_error("dom0 self-heal denied by policy")
    actions = []
    # Ensure runtime dir
    os.makedirs("/var/run/qvm-remote", mode=0o700, exist_ok=True)
    actions.append("runtime dir ensured")
    # Check daemon
    d = run(["systemctl", "is-active", "qvm-remote-dom0"], timeout=5)
    if d["out"].strip() != "active":
        run(["systemctl", "restart", "qvm-remote-dom0"], timeout=15)
        time.sleep(2)
        d2 = run(["systemctl", "is-active", "qvm-remote-dom0"], timeout=5)
        if d2["out"].strip() == "active":
            actions.append("daemon restarted successfully")
        else:
            actions.append("daemon restart FAILED: " + d2["err"])
    else:
        actions.append("daemon already healthy")
    # Check web (we're running, so just confirm port)
    actions.append("web server running (self)")
    # Check VM
    vm = run(["qvm-check", MANAGED_VM, "--running"], timeout=5)
    if vm["rc"] != 0:
        actions.append("VM {} not running (start manually if needed)".format(MANAGED_VM))
    else:
        actions.append("VM {} running".format(MANAGED_VM))
    return {"ok": True, "actions": actions}


def api_status(_params):
    svc = run(["systemctl", "is-active", "qvm-remote-dom0"], timeout=5)
    active = svc["out"].strip() == "active"
    if not active:
        p = run(["pgrep", "-f", "qvm-remote-dom0"], timeout=3)
        active = p["rc"] == 0
    en = run(["systemctl", "is-enabled", "qvm-remote-dom0"], timeout=5)
    enabled = en["out"].strip() == "enabled"
    ver = run(["qvm-remote-dom0", "--version"], timeout=5)
    vm_running = run(["qvm-check", MANAGED_VM, "--running"], timeout=5)
    conf = ""
    try:
        conf = open(CONF_FILE).read()
    except OSError:
        conf = "Config not found"
    return {
        "daemon_running": active,
        "daemon_enabled": enabled,
        "daemon_version": ver["out"].strip() if ver["rc"] == 0 else "unknown",
        "vm": MANAGED_VM,
        "vm_running": vm_running["rc"] == 0,
        "config": conf,
        "version": VERSION,
    }


def api_service_ctl(params):
    action = params.get("action", "")
    if action not in ("start", "stop", "restart", "enable", "disable"):
        return {"error": "Invalid action"}
    if not _check_dom0_write():
        return _policy_error("dom0 service control denied by policy")
    r = run(["systemctl", action, "qvm-remote-dom0"], timeout=15)
    return {"rc": r["rc"], "out": r["out"], "err": r["err"]}


def api_execute(params):
    cmd = params.get("cmd", "")
    timeout = int(params.get("timeout", 300))
    if not cmd:
        return {"error": "No command"}
    policy = _load_policy()
    blocked, reason = _check_cmd_blocked(cmd, policy)
    if blocked:
        return _policy_error(reason)
    ok, err = _check_perm("dom0", "full", policy)
    if not ok:
        return _policy_error(err)
    r = run(cmd, timeout=timeout, shell=True)
    return r


def api_vm_keys(_params):
    r = run(["qvm-remote-dom0", "keys"], timeout=10)
    vms = []
    if r["rc"] == 0:
        for line in r["out"].strip().splitlines():
            line = line.strip()
            if line:
                vms.append(line)
    return {"vms": vms}


def api_vm_authorize(params):
    vm = params.get("vm", "")
    key = params.get("key", "")
    if not vm or not key:
        return {"error": "Missing vm or key"}
    if not _check_dom0_write():
        return _policy_error("dom0 key management denied by policy")
    r = run(["qvm-remote-dom0", "authorize", vm, key], timeout=10)
    return r


def api_vm_revoke(params):
    vm = params.get("vm", "")
    if not vm:
        return {"error": "Missing vm"}
    if not _check_dom0_write():
        return _policy_error("dom0 key management denied by policy")
    r = run(["qvm-remote-dom0", "revoke", vm], timeout=10)
    return r


def api_vm_control(params):
    vm = params.get("vm", MANAGED_VM)
    action = params.get("action", "check")
    if action == "check":
        ok, err = _check_perm(vm, "monitor")
        if not ok:
            return _policy_error(err)
        r = run(["qvm-check", vm, "--running"], timeout=5)
        return {"running": r["rc"] == 0, "vm": vm}
    ok, err = _check_perm(vm, "manage")
    if not ok:
        return _policy_error(err)
    if action == "start":
        r = run(["qvm-start", vm], timeout=60)
    elif action == "stop":
        r = run(["qvm-shutdown", "--wait", "--timeout", "90", vm], timeout=120)
    else:
        return {"error": "Invalid action"}
    return r


def api_file_push(params):
    vm = params.get("vm", MANAGED_VM)
    src = params.get("src", "")
    dst = params.get("dst", "")
    if not src or not dst:
        return {"error": "Missing src or dst"}
    ok, err = _check_perm(vm, "full")
    if not ok:
        return _policy_error(err)
    r = run("cat '{}' | qvm-run --pass-io --no-gui {} 'cat > \"{}\"'".format(
        src, vm, dst), timeout=60, shell=True)
    return r


def api_file_pull(params):
    vm = params.get("vm", MANAGED_VM)
    src = params.get("src", "")
    dst = params.get("dst", "")
    if not src or not dst:
        return {"error": "Missing src or dst"}
    ok, err = _check_perm(vm, "full")
    if not ok:
        return _policy_error(err)
    r = run("qvm-run --pass-io --no-gui {} 'cat \"{}\"' > '{}'".format(
        vm, src, dst), timeout=60, shell=True)
    return r


def api_backup_status(_params):
    r = run("ls -lhrt /var/lib/qubes/backup* 2>/dev/null | tail -5; "
            "echo '---'; df -h / | tail -1", timeout=10, shell=True)
    return {"out": r["out"]}


def api_backup_start(params):
    dest = params.get("dest", "/mnt/backup/")
    if not _check_dom0_write():
        return _policy_error("dom0 backup operations denied by policy")
    r = run(["qvm-backup", "--yes", dest], timeout=7200)
    return r


def api_log(params):
    n = int(params.get("lines", 100))
    try:
        lines = open(LOG_FILE).readlines()[-n:]
        return {"log": "".join(lines)}
    except OSError:
        return {"log": "Log not found: " + LOG_FILE}


def api_device(_params):
    info = run("echo 'Hostname: '$(hostname); echo 'Kernel: '$(uname -r); "
               "xl info 2>/dev/null | grep -E 'total_memory|free_memory|nr_cpus|xen_version' || true; "
               "echo ''; qubes-prefs 2>/dev/null | head -10 || true",
               timeout=10, shell=True)
    vms = run(["qvm-ls", "--running", "--fields", "NAME,CLASS,LABEL,MEM,VCPUS"], timeout=10)
    return {"info": info["out"], "vms": vms["out"] if vms["rc"] == 0 else "Could not list VMs"}


def api_openclaw_status(_params):
    """Check OpenClaw containers and health."""
    results = {}
    for eng in ["podman", "docker"]:
        r = run([eng, "ps", "--filter", "name=openclaw", "--format",
                 "{{.Names}}\t{{.Status}}\t{{.Ports}}"], timeout=10)
        if r["rc"] == 0 and r["out"].strip():
            results["engine"] = eng
            results["containers"] = []
            for line in r["out"].strip().splitlines():
                parts = line.split("\t")
                results["containers"].append({
                    "name": parts[0] if parts else "",
                    "status": parts[1] if len(parts) > 1 else "",
                    "ports": parts[2] if len(parts) > 2 else "",
                })
            break
    if not results:
        results = {"engine": "none", "containers": []}
    health = run(["curl", "-sf", "--max-time", "3",
                   "http://127.0.0.1:32125/health"], timeout=5)
    results["proxy_healthy"] = health["rc"] == 0
    results["proxy_response"] = health["out"].strip() if health["rc"] == 0 else ""
    gw = run(["curl", "-sf", "--max-time", "3",
               "http://127.0.0.1:18789/"], timeout=5)
    results["gateway_healthy"] = gw["rc"] == 0
    return results


def api_openclaw_control(params):
    action = params.get("action", "")
    if action != "logs" and not _check_dom0_write():
        return _policy_error("dom0 container control denied by policy")
    eng = "podman" if run(["which", "podman"], timeout=3)["rc"] == 0 else "docker"
    cfg = _load_openclaw_config()
    # Pre-check: does compose work in dom0?
    test = run("{} compose version".format(eng), timeout=5, shell=True)
    if test["rc"] != 0:
        return {"error": "No container engine with compose support found in dom0. "
                "OpenClaw likely runs in VMs -- use VM Container Controls instead.",
                "hint": "vm_controls"}
    chk = run("{} compose config --quiet".format(eng), timeout=5, shell=True)
    if chk["rc"] != 0:
        return {"error": "No compose file found in dom0 working directory. "
                "OpenClaw runs in VMs, not dom0. Use VM Container Controls below.",
                "hint": "vm_controls"}
    t = cfg.get("timeouts", {})
    if action == "start":
        r = run("{} compose up -d".format(eng), timeout=t.get("start", 120), shell=True)
        return r
    elif action == "stop":
        r = run("{} compose down".format(eng), timeout=t.get("stop", 60), shell=True)
        return r
    elif action == "restart":
        run("{} compose down".format(eng), timeout=t.get("stop", 60), shell=True)
        r = run("{} compose up -d".format(eng), timeout=t.get("start", 120), shell=True)
        return r
    elif action == "logs":
        r = run("{} compose logs --tail 50".format(eng), timeout=t.get("logs", 15), shell=True)
        return r
    return {"error": "Invalid action"}


def api_openclaw_vm(params):
    """Manage OpenClaw containers inside a VM (run via qvm-run)."""
    vm = params.get("vm", MANAGED_VM)
    action = params.get("action", "status")
    required = "monitor" if action == "status" else "manage"
    ok, err = _check_perm(vm, required)
    if not ok:
        return _policy_error(err)
    if action == "status":
        r = run("qvm-run --pass-io --no-gui {} 'curl -sf --max-time 3 http://127.0.0.1:32125/health 2>/dev/null && echo PROXY_OK || echo PROXY_DOWN; "
                "curl -sf --max-time 3 http://127.0.0.1:18789/ >/dev/null 2>&1 && echo GW_OK || echo GW_DOWN; "
                "systemctl --user is-active openclaw-cursor-proxy 2>/dev/null || echo inactive; "
                "systemctl --user is-active openclaw-gateway 2>/dev/null || echo inactive; "
                "for eng in podman docker; do "
                "  $eng ps --filter name=openclaw --format \"{{{{.Names}}}}\\t{{{{.Status}}}}\" 2>/dev/null && break; "
                "done'".format(vm), timeout=15, shell=True)
        return r
    elif action == "start":
        r = run("qvm-run --pass-io --no-gui {} '"
                "cd ~/qubes-claw/openclaw 2>/dev/null || cd ~/openclaw-cursor 2>/dev/null || true; "
                "eng=$(command -v podman || command -v docker); "
                "$eng compose up -d 2>&1 || "
                "(systemctl --user start openclaw-cursor-proxy 2>/dev/null; "
                "systemctl --user start openclaw-gateway 2>/dev/null); "
                "echo DONE'".format(vm), timeout=120, shell=True)
        return r
    elif action == "stop":
        r = run("qvm-run --pass-io --no-gui {} '"
                "cd ~/qubes-claw/openclaw 2>/dev/null || cd ~/openclaw-cursor 2>/dev/null || true; "
                "eng=$(command -v podman || command -v docker); "
                "$eng compose down 2>&1 || "
                "(systemctl --user stop openclaw-cursor-proxy 2>/dev/null; "
                "systemctl --user stop openclaw-gateway 2>/dev/null); "
                "echo DONE'".format(vm), timeout=60, shell=True)
        return r
    elif action == "logs":
        r = run("qvm-run --pass-io --no-gui {} '"
                "cd ~/qubes-claw/openclaw 2>/dev/null || cd ~/openclaw-cursor 2>/dev/null || true; "
                "eng=$(command -v podman || command -v docker); "
                "$eng compose logs --tail 50 2>&1 || "
                "journalctl --user -u openclaw-cursor-proxy -u openclaw-gateway --no-pager -n 50 2>/dev/null'".format(vm),
                timeout=15, shell=True)
        return r
    return {"error": "Invalid action"}


def api_container_logs(params):
    """Get logs from a specific container (dom0 or VM)."""
    container = params.get("container", "")
    vm = params.get("vm", "")
    lines = params.get("lines", "50")
    eng = "podman" if run(["which", "podman"], timeout=3)["rc"] == 0 else "docker"
    if vm:
        r = run("qvm-run --pass-io --no-gui {} '"
                "eng=$(command -v podman || command -v docker); "
                "$eng logs --tail {} {} 2>&1'".format(vm, lines, container),
                timeout=15, shell=True)
    else:
        if not container:
            return {"error": "Missing container name"}
        r = run([eng, "logs", "--tail", str(lines), container], timeout=15)
    return r


def api_vm_log(params):
    """Per-VM qvm-remote command history with separate logs."""
    vm = params.get("vm", "")
    lines = int(params.get("lines", 50))
    if not vm:
        try:
            all_log = open(LOG_FILE).read()
            return {"log": all_log[-10000:]}
        except OSError:
            return {"log": "Log not found"}
    try:
        content = open(LOG_FILE).readlines()
        filtered = [l for l in content if "vm=" + vm in l]
        return {"log": "".join(filtered[-lines:])}
    except OSError:
        return {"log": "Log not found"}


def api_autostart_log(_params):
    """Read the autostart log from last login."""
    try:
        return {"log": open("/tmp/dom0-admin-autostart.log").read()}
    except OSError:
        return {"log": "No autostart log found"}


def api_journal(params):
    """Read systemd journal for a specific unit."""
    unit = params.get("unit", "qvm-remote-dom0")
    lines = int(params.get("lines", 100))
    since = params.get("since", "")
    allowed = {
        "qvm-remote-dom0", "qubes-global-admin-web",
        "qubes-admin-watchdog", "qubesd",
    }
    if unit not in allowed:
        return {"error": "Unit not allowed: " + unit}
    cmd = ["journalctl", "-u", unit, "--no-pager", "-n", str(min(lines, 500))]
    if since:
        cmd.extend(["--since", since])
    r = run(cmd, timeout=10)
    return {"log": r["out"], "unit": unit, "rc": r["rc"]}


def api_config_inspect(params):
    """Read a dom0 config file (read-only, whitelisted paths)."""
    path = params.get("path", "")
    allowed = {
        "/etc/qubes/remote.conf": "qvm-remote daemon config",
        "/etc/qubes/remote-admin-policy.json": "Admin policy",
        "/etc/qubes/openclaw.json": "OpenClaw config",
        "/etc/systemd/system/qvm-remote-dom0.service": "Daemon service unit",
        "/etc/systemd/system/qubes-global-admin-web.service": "Web UI service unit",
        "/etc/systemd/system/qubes-admin-watchdog.service": "Watchdog service",
        "/etc/systemd/system/qubes-admin-watchdog.timer": "Watchdog timer",
    }
    if not path:
        return {"files": [{"path": k, "desc": v} for k, v in allowed.items()]}
    if path not in allowed:
        return {"error": "Path not allowed"}
    try:
        return {"path": path, "desc": allowed[path], "content": open(path).read()}
    except OSError as e:
        return {"path": path, "error": str(e)}


def api_suggestions(params):
    """Return smart suggestions for dropdowns and datalists."""
    kind = params.get("kind", "")
    vm = params.get("vm", "")
    if kind == "vm-prefs":
        return {"items": [
            "autostart", "debug", "default_dispvm", "default_user",
            "include_in_backups", "ip", "kernel", "kernelopts", "label",
            "mac", "maxmem", "memory", "name", "netvm", "provides_network",
            "qrexec_timeout", "template", "template_for_dispvms", "vcpus",
            "virt_mode",
        ]}
    if kind == "global-prefs":
        return {"items": [
            "clockvm", "default_template", "default_fw_netvm",
            "default_netvm", "default_kernel", "default_pool", "updatevm",
        ]}
    if kind == "features":
        return {"items": [
            "gui", "gui-default-allow-utf8-titles", "internal",
            "os-distribution", "os-eol", "os-version",
            "qrexec", "servicevm", "supported-service.qubes-update-check",
            "updates-available",
        ]}
    if kind == "services":
        return {"items": [
            "crond", "cups", "meminfo-writer", "network-manager",
            "qubes-firewall", "qubes-network", "qubes-update-check",
            "qubes-updates-proxy",
        ]}
    if kind == "tags":
        r = run(["qvm-tags", vm], timeout=5) if vm else {"out": "", "rc": 1}
        common = ["audiovm-dom0", "created-by-dom0", "guivm-dom0",
                   "anon-gateway", "anon-workstation", "whonix-updatevm"]
        existing = [t.strip() for t in r["out"].splitlines() if t.strip()] if r.get("rc") == 0 else []
        return {"items": sorted(set(common + existing))}
    if kind == "containers" and vm:
        eng = "podman" if run(["which", "podman"], timeout=3)["rc"] == 0 else "docker"
        r = run("qvm-run --pass-io --no-gui {} '"
                "eng=$(command -v podman || command -v docker); "
                "$eng ps -a --format {{{{.Names}}}} 2>/dev/null'".format(vm),
                timeout=10, shell=True)
        names = [n.strip() for n in r["out"].splitlines() if n.strip()] if r.get("rc") == 0 else []
        return {"items": names}
    if kind == "policies":
        r = run(["ls", "/etc/qubes/policy.d/"], timeout=5)
        items = [f.strip() for f in r["out"].splitlines() if f.strip()] if r.get("rc") == 0 else []
        return {"items": items}
    return {"items": []}


def api_qvm_ls(_params):
    r = run(["qvm-ls", "--fields", "NAME,CLASS,LABEL,STATE,MEM,VCPUS,NETVM",
             "--raw-data"], timeout=10)
    return {"out": r["out"], "rc": r["rc"]}


def api_queue_health(_params):
    """Report queue state across all authorized VMs for dashboard monitoring."""
    r = run(["qvm-remote-dom0", "queue", "status"], timeout=15)
    return {"out": r["out"], "rc": r["rc"], "err": r["err"]}


def api_queue_action(params):
    """Queue management: clean, recover, debug."""
    action = params.get("action", "status")
    vm = params.get("vm", "")
    if action not in ("status", "clean", "recover", "debug"):
        return {"error": "Invalid action"}
    if action != "status" and not _check_dom0_write():
        return _policy_error("dom0 queue management denied by policy")
    cmd = ["qvm-remote-dom0", "queue", action]
    if vm:
        cmd.append(vm)
    r = run(cmd, timeout=30)
    return r


def api_admin_policy(params):
    """Manage the admin policy: read, update VM permissions, set dom0 level."""
    action = params.get("action", "get")

    if action == "get":
        policy = _load_policy()
        all_vms = run(["qvm-ls", "--raw-list"], timeout=10)
        vm_list = []
        if all_vms["rc"] == 0:
            vm_list = [v.strip() for v in all_vms["out"].strip().splitlines() if v.strip()]
        return {"policy": policy, "available_vms": vm_list}

    if action == "set_vm":
        vm = params.get("vm", "")
        level = params.get("level", "")
        if not vm or level not in PERM_LEVELS:
            return {"error": "Missing vm or invalid level (deny/monitor/manage/full)"}
        policy = _load_policy()
        if "vms" not in policy:
            policy["vms"] = {}
        policy["vms"][vm] = level
        if _save_policy(policy):
            return {"ok": True, "vm": vm, "level": level}
        return {"error": "Failed to save policy"}

    if action == "remove_vm":
        vm = params.get("vm", "")
        if not vm:
            return {"error": "Missing vm"}
        policy = _load_policy()
        if vm in policy.get("vms", {}):
            del policy["vms"][vm]
            if _save_policy(policy):
                return {"ok": True, "removed": vm}
        return {"error": "VM not in policy or save failed"}

    if action == "set_dom0":
        level = params.get("level", "")
        if level not in PERM_LEVELS:
            return {"error": "Invalid level"}
        policy = _load_policy()
        policy["dom0"] = level
        if _save_policy(policy):
            return {"ok": True, "dom0": level}
        return {"error": "Failed to save policy"}

    if action == "set_default":
        level = params.get("level", "")
        if level not in PERM_LEVELS:
            return {"error": "Invalid level"}
        policy = _load_policy()
        policy["default"] = level
        if _save_policy(policy):
            return {"ok": True, "default": level}
        return {"error": "Failed to save policy"}

    if action == "set_dom0_read":
        val = params.get("value", "true") == "true"
        policy = _load_policy()
        policy["dom0_read_allowed"] = val
        if _save_policy(policy):
            return {"ok": True, "dom0_read_allowed": val}
        return {"error": "Failed to save policy"}

    if action == "set_blocked":
        cmds = params.get("commands", "")
        if not cmds:
            return {"error": "Missing commands"}
        policy = _load_policy()
        policy["blocked_commands"] = [c.strip() for c in cmds.split("\n") if c.strip()]
        if _save_policy(policy):
            return {"ok": True}
        return {"error": "Failed to save policy"}

    if action == "reset":
        if _save_policy(dict(DEFAULT_POLICY)):
            return {"ok": True, "policy": DEFAULT_POLICY}
        return {"error": "Failed to reset policy"}

    return {"error": "Invalid action"}


def api_connect(params):
    """Connect a new VM: authorize + add to config + init dirs."""
    vm = params.get("vm", "")
    key = params.get("key", "")
    if not vm:
        return {"error": "Missing vm"}
    if not _check_dom0_write():
        return _policy_error("dom0 VM connection management denied by policy")
    cmd = ["qvm-remote-dom0", "connect", vm]
    if key:
        cmd.append(key)
    r = run(cmd, timeout=30)
    return r


def api_disconnect(params):
    """Disconnect a VM: revoke + remove from config + clean queue."""
    vm = params.get("vm", "")
    if not vm:
        return {"error": "Missing vm"}
    if not _check_dom0_write():
        return _policy_error("dom0 VM disconnection denied by policy")
    r = run(["qvm-remote-dom0", "disconnect", vm], timeout=30)
    return r


def api_daemon_status(_params):
    """Full daemon status report."""
    r = run(["qvm-remote-dom0", "status"], timeout=15)
    return {"out": r["out"], "rc": r["rc"]}


def api_vm_prefs(params):
    vm = params.get("vm", "")
    prop = params.get("prop", "")
    val = params.get("val", "")
    if not vm:
        return {"error": "Missing vm"}
    if prop and val:
        ok, err = _check_perm(vm, "manage")
        if not ok:
            return _policy_error(err)
        r = run(["qvm-prefs", vm, prop, val], timeout=10)
        return r
    ok, err = _check_perm(vm, "monitor")
    if not ok:
        return _policy_error(err)
    if prop:
        r = run(["qvm-prefs", vm, prop], timeout=10)
        return {"value": r["out"].strip(), "rc": r["rc"]}
    r = run(["qvm-prefs", vm], timeout=10)
    return {"out": r["out"], "rc": r["rc"]}


def api_qubes_prefs(params):
    prop = params.get("prop", "")
    val = params.get("val", "")
    if prop and val:
        if not _check_dom0_write():
            return _policy_error("dom0 global preferences modification denied by policy")
        r = run(["qubes-prefs", prop, val], timeout=10)
        return r
    if not _check_dom0_read():
        return _policy_error("dom0 read denied by policy")
    if prop:
        r = run(["qubes-prefs", prop], timeout=10)
        return {"value": r["out"].strip(), "rc": r["rc"]}
    r = run(["qubes-prefs"], timeout=10)
    return {"out": r["out"], "rc": r["rc"]}


def api_firewall(params):
    vm = params.get("vm", "")
    action = params.get("action", "list")
    if not vm:
        return {"error": "Missing vm"}
    required = "monitor" if action == "list" else "manage"
    ok, err = _check_perm(vm, required)
    if not ok:
        return _policy_error(err)
    if action == "list":
        r = run(["qvm-firewall", vm, "list"], timeout=10)
    elif action == "reset":
        r = run(["qvm-firewall", vm, "reset"], timeout=10)
    elif action == "add":
        rule = params.get("rule", "")
        if not rule:
            return {"error": "Missing rule"}
        r = run("qvm-firewall {} add {}".format(vm, rule), timeout=10, shell=True)
    else:
        return {"error": "Invalid action"}
    return r


def api_devices(params):
    dtype = params.get("type", "usb")
    if dtype not in ("usb", "pci", "block", "mic"):
        return {"error": "Invalid type"}
    if not _check_dom0_read():
        return _policy_error("dom0 device listing denied by policy")
    r = run(["qvm-device", dtype, "list"], timeout=10)
    return {"out": r["out"], "rc": r["rc"]}


def api_device_ctl(params):
    dtype = params.get("type", "usb")
    action = params.get("action", "")
    vm = params.get("vm", "")
    port = params.get("port", "")
    if not action or not vm or not port:
        return {"error": "Missing action/vm/port"}
    ok, err = _check_perm(vm, "full")
    if not ok:
        return _policy_error(err)
    if action == "attach":
        r = run(["qvm-device", dtype, "attach", vm, port], timeout=30)
    elif action == "detach":
        r = run(["qvm-device", dtype, "detach", vm, port], timeout=15)
    else:
        return {"error": "Invalid action"}
    return r


def api_features(params):
    vm = params.get("vm", "")
    feat = params.get("feature", "")
    val = params.get("value", "")
    if not vm:
        return {"error": "Missing vm"}
    if feat and val:
        ok, err = _check_perm(vm, "manage")
        if not ok:
            return _policy_error(err)
        r = run(["qvm-features", vm, feat, val], timeout=10)
        return r
    ok, err = _check_perm(vm, "monitor")
    if not ok:
        return _policy_error(err)
    if feat:
        r = run(["qvm-features", vm, feat], timeout=10)
        return {"value": r["out"].strip(), "rc": r["rc"]}
    r = run(["qvm-features", vm], timeout=10)
    return {"out": r["out"], "rc": r["rc"]}


def api_tags(params):
    vm = params.get("vm", "")
    action = params.get("action", "list")
    tag = params.get("tag", "")
    if not vm:
        return {"error": "Missing vm"}
    required = "monitor" if action == "list" else "manage"
    ok, err = _check_perm(vm, required)
    if not ok:
        return _policy_error(err)
    if action == "list":
        r = run(["qvm-tags", vm], timeout=10)
    elif action == "add" and tag:
        r = run(["qvm-tags", vm, "add", tag], timeout=10)
    elif action == "del" and tag:
        r = run(["qvm-tags", vm, "del", tag], timeout=10)
    else:
        return {"error": "Invalid action/tag"}
    return r


def api_services(params):
    vm = params.get("vm", "")
    svc = params.get("service", "")
    action = params.get("action", "list")
    if not vm:
        return {"error": "Missing vm"}
    required = "monitor" if action == "list" else "manage"
    ok, err = _check_perm(vm, required)
    if not ok:
        return _policy_error(err)
    if action == "list":
        r = run(["qvm-service", vm], timeout=10)
    elif action == "enable" and svc:
        r = run(["qvm-service", vm, svc, "--enable"], timeout=10)
    elif action == "disable" and svc:
        r = run(["qvm-service", vm, svc, "--disable"], timeout=10)
    elif action == "default" and svc:
        r = run(["qvm-service", vm, svc, "--default"], timeout=10)
    else:
        return {"error": "Invalid action/service"}
    return r


def api_templates(_params):
    if not _check_dom0_read():
        return _policy_error("dom0 read denied by policy")
    installed = run(["qvm-template", "list", "--installed"], timeout=30)
    return {"out": installed["out"], "rc": installed["rc"]}


def api_policy(params):
    action = params.get("action", "list")
    if not _check_dom0_read():
        return _policy_error("dom0 policy read denied")
    if action == "list":
        r = run("ls -la /etc/qubes/policy.d/ 2>/dev/null", timeout=5, shell=True)
        return {"out": r["out"]}
    name = params.get("name", "")
    if action == "read" and name:
        name = os.path.basename(name)
        path = "/etc/qubes/policy.d/" + name
        try:
            return {"out": open(path).read()}
        except OSError as e:
            return {"error": str(e)}
    return {"error": "Invalid action"}


def api_dom0_update(params):
    action = params.get("action", "check")
    if action == "update":
        if not _check_dom0_write():
            return _policy_error("dom0 update denied by policy")
    elif action != "check":
        return {"error": "Invalid action"}
    if action == "check":
        r = run(["qubes-dom0-update", "--check-only"], timeout=120)
    else:
        r = run(["qubes-dom0-update", "-y"], timeout=600)
    return r


def api_xen(_params):
    info = run("xl info 2>/dev/null", timeout=10, shell=True)
    vlist = run("xl list 2>/dev/null", timeout=10, shell=True)
    uptime = run("xl uptime 2>/dev/null", timeout=10, shell=True)
    return {
        "info": info["out"],
        "list": vlist["out"],
        "uptime": uptime["out"],
    }


# ── New endpoints: vm-list, vm-run, vm-setup, template install, openclaw config, panel info ──

def api_vm_list(_params):
    """Cached VM list with name, class, label, state for dropdown population."""
    now = time.time()
    if _vm_list_cache["data"] and now - _vm_list_cache["ts"] < 5:
        return _vm_list_cache["data"]
    r = run(["qvm-ls", "--fields", "NAME,CLASS,LABEL,STATE", "--raw-data"], timeout=10)
    vms = []
    if r["rc"] == 0:
        for line in r["out"].strip().splitlines():
            parts = line.split("|")
            if len(parts) >= 4 and parts[0] != "NAME":
                vms.append({"name": parts[0], "cls": parts[1],
                            "label": parts[2], "state": parts[3]})
    vms.sort(key=lambda v: (0 if v["state"] == "Running" else 1, v["name"]))
    result = {"vms": vms}
    _vm_list_cache["data"] = result
    _vm_list_cache["ts"] = now
    return result


def api_vm_run(params):
    """Run a command inside a VM via qvm-run with full flag support."""
    vm = params.get("vm", "")
    cmd = params.get("cmd", "")
    user = params.get("user", "")
    dispvm = params.get("dispvm", False)
    service = params.get("service", False)
    no_auto = params.get("no_auto", False)
    timeout = int(params.get("timeout", 120))
    if not cmd:
        return {"error": "No command"}
    if dispvm:
        ok, err = _check_perm("dom0", "full")
        if not ok:
            return _policy_error(err)
        args = ["qvm-run", "--dispvm"]
        if vm:
            args[-1] = "--dispvm=" + vm
    else:
        if not vm:
            return {"error": "No VM specified"}
        ok, err = _check_perm(vm, "manage")
        if not ok:
            return _policy_error(err)
        args = ["qvm-run"]
    args.extend(["--pass-io", "--no-gui"])
    if no_auto:
        args.append("--no-autostart")
    if service:
        args.append("--service")
    if user:
        args.extend(["--user", user])
    if not dispvm:
        args.append(vm)
    args.append(cmd)
    r = run(args, timeout=timeout)
    return r


def api_vm_setup(params):
    """One-click VM onboarding: install client, generate key, authorize, test."""
    vm = params.get("vm", "")
    if not vm:
        return {"error": "Missing vm"}
    if not _check_dom0_write():
        return _policy_error("dom0 VM setup denied by policy")
    steps = []
    # Check if VM is running
    chk = run(["qvm-check", vm, "--running"], timeout=5)
    if chk["rc"] != 0:
        st = run(["qvm-start", vm], timeout=60)
        if st["rc"] != 0:
            return {"error": "Failed to start VM: " + st["err"], "steps": steps}
        steps.append("Started VM")
        time.sleep(2)
    else:
        steps.append("VM already running")
    # Check if client installed
    has_client = run("qvm-run --pass-io --no-gui {} 'which qvm-remote 2>/dev/null'".format(vm),
                     timeout=10, shell=True)
    if has_client["rc"] != 0 or not has_client["out"].strip():
        # Push client from this repo or /usr/bin
        src = None
        for p in ["/usr/bin/qvm-remote",
                  os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "vm", "qvm-remote")]:
            if os.path.isfile(p):
                src = p
                break
        if not src:
            return {"error": "Cannot find qvm-remote client to push", "steps": steps}
        push = run("cat '{}' | qvm-run --pass-io --no-gui {} "
                    "'sudo tee /usr/bin/qvm-remote > /dev/null && sudo chmod 755 /usr/bin/qvm-remote'".format(
                        src, vm), timeout=30, shell=True)
        if push["rc"] != 0:
            return {"error": "Failed to install client: " + push["err"], "steps": steps}
        steps.append("Installed client")
    else:
        steps.append("Client already installed")
    # Check/generate key
    key_check = run("qvm-run --pass-io --no-gui {} "
                    "'test -f ~/.qvm-remote/auth.key && cat ~/.qvm-remote/auth.key'".format(vm),
                    timeout=10, shell=True)
    if key_check["rc"] != 0 or len(key_check["out"].strip()) < 32:
        gen = run("qvm-run --pass-io --no-gui {} "
                  "'qvm-remote key gen 2>/dev/null; cat ~/.qvm-remote/auth.key'".format(vm),
                  timeout=15, shell=True)
        if gen["rc"] != 0 or len(gen["out"].strip()) < 32:
            return {"error": "Failed to generate key", "steps": steps}
        key = gen["out"].strip().splitlines()[-1].strip()
        steps.append("Generated new key")
    else:
        key = key_check["out"].strip().splitlines()[-1].strip()
        steps.append("Key already exists")
    # Authorize in dom0
    auth = run(["qvm-remote-dom0", "connect", vm, key], timeout=30)
    if auth["rc"] != 0:
        return {"error": "Failed to authorize: " + auth["err"], "steps": steps}
    steps.append("Authorized in dom0")
    # Verify
    time.sleep(2)
    test = run("qvm-run --pass-io --no-gui {} 'qvm-remote ping 2>&1'".format(vm),
               timeout=15, shell=True)
    if "responding" in test["out"].lower() or test["rc"] == 0:
        steps.append("Connection verified")
    else:
        steps.append("Warning: ping did not confirm (daemon may need restart)")
    return {"ok": True, "vm": vm, "steps": steps}


def api_template_install(params):
    """Install qvm-remote client into a template VM."""
    template = params.get("template", "")
    if not template:
        return {"error": "Missing template"}
    if not _check_dom0_write():
        return _policy_error("dom0 template install denied by policy")
    steps = []
    # Start template if needed
    chk = run(["qvm-check", template, "--running"], timeout=5)
    if chk["rc"] != 0:
        st = run(["qvm-start", template], timeout=60)
        if st["rc"] != 0:
            return {"error": "Failed to start template: " + st["err"]}
        steps.append("Started template")
        time.sleep(3)
    else:
        steps.append("Template already running")
    # Find client binary
    src = None
    for p in ["/usr/bin/qvm-remote",
              os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "vm", "qvm-remote")]:
        if os.path.isfile(p):
            src = p
            break
    if not src:
        return {"error": "Cannot find qvm-remote client binary", "steps": steps}
    # Push to template
    push = run("cat '{}' | qvm-run --pass-io --no-gui {} "
                "'sudo tee /usr/bin/qvm-remote > /dev/null && sudo chmod 755 /usr/bin/qvm-remote'".format(
                    src, template), timeout=30, shell=True)
    if push["rc"] != 0:
        return {"error": "Failed to push client: " + push["err"], "steps": steps}
    steps.append("Installed /usr/bin/qvm-remote")
    # Verify
    ver = run("qvm-run --pass-io --no-gui {} 'qvm-remote --version 2>&1'".format(template),
              timeout=10, shell=True)
    steps.append("Version: " + (ver["out"].strip() if ver["rc"] == 0 else "unknown"))
    # Shut down template
    sd = run(["qvm-shutdown", "--wait", "--timeout", "60", template], timeout=90)
    if sd["rc"] == 0:
        steps.append("Template shut down (AppVMs will get client on next boot)")
    else:
        steps.append("Warning: template still running, shut down manually for changes to propagate")
    return {"ok": True, "template": template, "steps": steps}


def _load_openclaw_config():
    try:
        with open(OPENCLAW_CONF) as f:
            return json.loads(f.read())
    except (OSError, json.JSONDecodeError):
        return {
            "vms": [MANAGED_VM],
            "compose_paths": ["~/qubes-claw/openclaw", "~/openclaw-cursor"],
            "engine": "auto",
            "proxy_port": 32125,
            "gateway_port": 18789,
            "timeouts": {"start": 120, "stop": 60, "status": 15, "logs": 15},
            "connect_tcp_policy": "50-openclaw.policy",
            "autostart": False,
        }


def _save_openclaw_config(cfg):
    try:
        os.makedirs(os.path.dirname(OPENCLAW_CONF), exist_ok=True)
        with open(OPENCLAW_CONF, "w") as f:
            json.dump(cfg, f, indent=2)
        os.chmod(OPENCLAW_CONF, 0o600)
        return True
    except OSError:
        return False


def api_openclaw_config(params):
    """Get or update OpenClaw configuration."""
    action = params.get("action", "get")
    if action == "get":
        return {"config": _load_openclaw_config()}
    if action == "save":
        if not _check_dom0_write():
            return _policy_error("dom0 OpenClaw config denied by policy")
        cfg = _load_openclaw_config()
        for k in ("vms", "compose_paths", "engine", "proxy_port", "gateway_port",
                   "connect_tcp_policy", "autostart"):
            if k in params:
                cfg[k] = params[k]
        if "timeouts" in params and isinstance(params["timeouts"], dict):
            cfg["timeouts"] = params["timeouts"]
        if _save_openclaw_config(cfg):
            return {"ok": True, "config": cfg}
        return {"error": "Failed to save config"}
    return {"error": "Invalid action"}


def api_panel_info(_params):
    """Admin panel hosting and security information."""
    policy = _load_policy()
    keys_r = run(["qvm-remote-dom0", "keys"], timeout=10)
    authorized = []
    if keys_r["rc"] == 0:
        authorized = [v.strip() for v in keys_r["out"].strip().splitlines() if v.strip()]
    vm_ip = ""
    if MANAGED_VM:
        ip_r = run(["qvm-prefs", MANAGED_VM, "ip"], timeout=5)
        vm_ip = ip_r["out"].strip() if ip_r["rc"] == 0 else ""
    vm_perms = {}
    for v in authorized:
        vm_perms[v] = _get_vm_perm(v, policy)
    return {
        "host": "dom0",
        "bind": "{}:{}".format(HOST, PORT),
        "managed_vm": MANAGED_VM,
        "vm_ip": vm_ip,
        "transport": "qrexec file-based queue, HMAC-SHA256 authenticated",
        "policy_file": POLICY_FILE,
        "dom0_level": policy.get("dom0", "deny"),
        "default_level": policy.get("default", "monitor"),
        "dom0_read_allowed": policy.get("dom0_read_allowed", True),
        "authorized_vms": authorized,
        "vm_permissions": vm_perms,
        "network": "Air-gapped. dom0 has no netvm. Not accessible from any network.",
        "socket": "Listening on {} only (not 0.0.0.0)".format(HOST),
    }


ROUTES = {
    "/api/status": api_status,
    "/api/service": api_service_ctl,
    "/api/execute": api_execute,
    "/api/vm/keys": api_vm_keys,
    "/api/vm/authorize": api_vm_authorize,
    "/api/vm/revoke": api_vm_revoke,
    "/api/vm/control": api_vm_control,
    "/api/vm/prefs": api_vm_prefs,
    "/api/file/push": api_file_push,
    "/api/file/pull": api_file_pull,
    "/api/backup/status": api_backup_status,
    "/api/backup/start": api_backup_start,
    "/api/log": api_log,
    "/api/device": api_device,
    "/api/devices": api_devices,
    "/api/devices/ctl": api_device_ctl,
    "/api/openclaw/status": api_openclaw_status,
    "/api/openclaw/control": api_openclaw_control,
    "/api/openclaw/vm": api_openclaw_vm,
    "/api/openclaw/config": api_openclaw_config,
    "/api/container/logs": api_container_logs,
    "/api/vm-log": api_vm_log,
    "/api/autostart-log": api_autostart_log,
    "/api/qubes-prefs": api_qubes_prefs,
    "/api/firewall": api_firewall,
    "/api/features": api_features,
    "/api/tags": api_tags,
    "/api/services": api_services,
    "/api/templates": api_templates,
    "/api/policy": api_policy,
    "/api/dom0-update": api_dom0_update,
    "/api/xen": api_xen,
    "/api/qvm-ls": api_qvm_ls,
    "/api/queue-health": api_queue_health,
    "/api/queue": api_queue_action,
    "/api/connect": api_connect,
    "/api/disconnect": api_disconnect,
    "/api/daemon-status": api_daemon_status,
    "/api/admin-policy": api_admin_policy,
    "/api/vm-list": api_vm_list,
    "/api/vm-run": api_vm_run,
    "/api/vm/setup": api_vm_setup,
    "/api/template/install-client": api_template_install,
    "/api/panel-info": api_panel_info,
    "/api/health": api_health,
    "/api/self-heal": api_self_heal,
    "/api/journal": api_journal,
    "/api/config-inspect": api_config_inspect,
    "/api/suggestions": api_suggestions,
}


# ── HTTP Server ──────────────────────────────────────────────────

class Handler(http.server.BaseHTTPRequestHandler):
    def log_message(self, fmt, *args):
        pass

    def _cors(self):
        self.send_header("Access-Control-Allow-Origin", "http://127.0.0.1:" + str(PORT))
        self.send_header("Cache-Control", "no-cache")

    def _json_response(self, code, data):
        self.send_response(code)
        self.send_header("Content-Type", "application/json")
        self._cors()
        self.end_headers()
        self.wfile.write(json.dumps(data).encode())

    def do_GET(self):
        parsed = urllib.parse.urlparse(self.path)
        if parsed.path == "/" or parsed.path == "/index.html":
            self.send_response(200)
            self.send_header("Content-Type", "text/html; charset=utf-8")
            self._cors()
            self.end_headers()
            self.wfile.write(HTML.encode())
            return
        if parsed.path == "/api/stream/exec":
            params = dict(urllib.parse.parse_qsl(parsed.query))
            self._stream_exec(params)
            return
        if parsed.path == "/api/stream/vm-run":
            params = dict(urllib.parse.parse_qsl(parsed.query))
            self._stream_vm_run(params)
            return
        if parsed.path in ROUTES:
            params = dict(urllib.parse.parse_qsl(parsed.query))
            result = ROUTES[parsed.path](params)
            status = 403 if result.get("policy_denied") else 200
            self._json_response(status, result)
            return
        self.send_error(404)

    def do_POST(self):
        parsed = urllib.parse.urlparse(self.path)
        if parsed.path in ROUTES:
            length = int(self.headers.get("Content-Length", 0))
            body = self.rfile.read(length).decode() if length else "{}"
            try:
                params = json.loads(body)
            except json.JSONDecodeError:
                params = dict(urllib.parse.parse_qsl(body))
            result = ROUTES[parsed.path](params)
            status = 403 if result.get("policy_denied") else 200
            self._json_response(status, result)
            return
        self.send_error(404)

    def _stream_exec(self, params):
        """Server-Sent Events: stream command output line by line."""
        cmd = params.get("cmd", "")
        timeout = int(params.get("timeout", 300))
        if not cmd:
            self.send_error(400, "No command")
            return
        policy = _load_policy()
        blocked, reason = _check_cmd_blocked(cmd, policy)
        if blocked:
            self._json_response(403, _policy_error(reason))
            return
        ok, err = _check_perm("dom0", "full", policy)
        if not ok:
            self._json_response(403, _policy_error(err))
            return
        self.send_response(200)
        self.send_header("Content-Type", "text/event-stream")
        self.send_header("Cache-Control", "no-cache")
        self.send_header("Connection", "keep-alive")
        self._cors()
        self.end_headers()
        try:
            proc = subprocess.Popen(
                cmd, shell=True,
                stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
                text=True, bufsize=1)
            for line in proc.stdout:
                self.wfile.write(("data: " + json.dumps({"line": line}) + "\n\n").encode())
                self.wfile.flush()
            proc.wait(timeout=timeout + 5)
            self.wfile.write(("data: " + json.dumps(
                {"done": True, "rc": proc.returncode}) + "\n\n").encode())
            self.wfile.flush()
        except subprocess.TimeoutExpired:
            proc.kill()
            self.wfile.write(("data: " + json.dumps(
                {"done": True, "rc": 124, "line": "Timed out\n"}) + "\n\n").encode())
            self.wfile.flush()
        except Exception as e:
            try:
                self.wfile.write(("data: " + json.dumps(
                    {"done": True, "rc": 1, "line": str(e) + "\n"}) + "\n\n").encode())
                self.wfile.flush()
            except Exception:
                pass


    def _stream_vm_run(self, params):
        """SSE stream for qvm-run output."""
        vm = params.get("vm", "")
        cmd = params.get("cmd", "")
        user = params.get("user", "")
        dispvm = params.get("dispvm", "") == "true"
        no_auto = params.get("no_auto", "") == "true"
        timeout = int(params.get("timeout", 120))
        if not cmd:
            self.send_error(400, "No command")
            return
        if dispvm:
            ok, err = _check_perm("dom0", "full")
        elif vm:
            ok, err = _check_perm(vm, "manage")
        else:
            self._json_response(400, {"error": "No VM"})
            return
        if not ok:
            self._json_response(403, _policy_error(err))
            return
        args = ["qvm-run", "--pass-io", "--no-gui"]
        if dispvm:
            args.append("--dispvm" + ("=" + vm if vm else ""))
        else:
            if no_auto:
                args.append("--no-autostart")
            if user:
                args.extend(["--user", user])
            args.append(vm)
        args.append(cmd)
        self.send_response(200)
        self.send_header("Content-Type", "text/event-stream")
        self.send_header("Cache-Control", "no-cache")
        self.send_header("Connection", "keep-alive")
        self._cors()
        self.end_headers()
        try:
            proc = subprocess.Popen(args, stdout=subprocess.PIPE,
                                    stderr=subprocess.STDOUT, text=True, bufsize=1)
            for line in proc.stdout:
                self.wfile.write(("data: " + json.dumps({"line": line}) + "\n\n").encode())
                self.wfile.flush()
            proc.wait(timeout=timeout + 5)
            self.wfile.write(("data: " + json.dumps(
                {"done": True, "rc": proc.returncode}) + "\n\n").encode())
            self.wfile.flush()
        except subprocess.TimeoutExpired:
            proc.kill()
            self.wfile.write(("data: " + json.dumps(
                {"done": True, "rc": 124, "line": "Timed out\n"}) + "\n\n").encode())
            self.wfile.flush()
        except Exception as e:
            try:
                self.wfile.write(("data: " + json.dumps(
                    {"done": True, "rc": 1, "line": str(e) + "\n"}) + "\n\n").encode())
                self.wfile.flush()
            except Exception:
                pass


class ThreadedServer(socketserver.ThreadingMixIn, http.server.HTTPServer):
    daemon_threads = True
    allow_reuse_address = True


# ── HTML / CSS / JS (single-page app) ────────────────────────────

HTML = r"""<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Qubes Global Admin</title>
<style>
:root {
  --blue: #4180c9;
  --dark-blue: #4488df;
  --bg: #f2f2f2;
  --bg-white: #ffffff;
  --frame: #979797;
  --sep: #cdcdcd;
  --soft: #858585;
  --misc: #979797;
  --text: #000000;
  --ok: #2d8a4e;
  --warn: #d4a017;
  --err: #c0392b;
  --info-bg: #f0e9e3;
  --problem-bg: #fce9e3;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  font-family: 'Source Sans Pro', 'Cantarell', 'Segoe UI', sans-serif;
  font-size: 14px;
  color: var(--text);
  background: var(--bg);
  display: flex;
  flex-direction: column;
  height: 100vh;
}

/* Title bar */
.titlebar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 24px;
  background: var(--bg);
  border-bottom: 1px solid var(--sep);
}
.titlebar h1 { font-size: 18px; font-weight: 700; }
.titlebar .ver { font-size: 12px; color: var(--soft); font-weight: 600; }

/* Spinner */
@keyframes spin { to { transform: rotate(360deg); } }

/* Pending changes bar */
.pending-bar {
  display: none;
  position: sticky; bottom: 0; z-index: 100;
  background: #fff3cd; border-top: 2px solid #ffc107;
  padding: 8px 24px; font-size: 13px; font-weight: 500;
  align-items: center; gap: 12px;
}
.pending-bar.visible { display: flex; }

/* Connection bar */
.connbar {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 6px 24px;
  border-bottom: 1px solid var(--sep);
  font-size: 13px;
  transition: background 0.3s;
}
.connbar.ok { background: #e6f4ea; }
.connbar.warn { background: var(--info-bg); }
.connbar.err { background: var(--problem-bg); }
.connbar .dot { font-size: 16px; }
.connbar .dot.ok { color: var(--ok); }
.connbar .dot.warn { color: var(--warn); }
.connbar .dot.err { color: var(--err); }
.connbar .vm { margin-left: auto; font-weight: 600; color: var(--soft); }

/* Layout */
.main { display: flex; flex: 1; overflow: hidden; }

/* Sidebar */
.sidebar {
  width: 200px;
  min-width: 200px;
  background: var(--bg);
  border-right: 1px solid var(--sep);
  display: flex;
  flex-direction: column;
}
.sidebar .tab {
  padding: 14px 24px;
  font-weight: 600;
  font-size: 13px;
  cursor: pointer;
  border: none;
  background: transparent;
  text-align: left;
  color: var(--text);
  border-bottom: 1px solid var(--sep);
  transition: background 0.15s;
}
.sidebar .tab:hover { background: #e7e7e7; }
.sidebar .tab.active { background: var(--blue); color: white; }

/* Content */
.content {
  flex: 1;
  overflow-y: auto;
  padding: 50px 100px;
  background: var(--bg);
}
@media (max-width: 900px) { .content { padding: 20px 24px; } }

.page { display: none; }
.page.active { display: block; }

/* Typography */
h2 { font-weight: 400; font-size: 22px; margin-bottom: 4px; }
h3 { font-weight: 700; font-size: 15px; margin-top: 24px; margin-bottom: 4px; }
.expl { font-size: 12px; color: var(--misc); margin-bottom: 16px; margin-left: 2px; }

/* Cards */
.card {
  background: var(--bg-white);
  border: 1px solid var(--sep);
  border-radius: 5px;
  padding: 16px 20px;
  margin: 10px 0;
}
.card-title { font-weight: 700; font-size: 13px; color: var(--soft); margin-bottom: 8px; }

/* Status dots */
.dot-inline { display: inline-flex; align-items: center; gap: 6px; }
.dot-inline .d { font-size: 14px; }
.dot-inline .d.ok { color: var(--ok); }
.dot-inline .d.warn { color: var(--warn); }
.dot-inline .d.err { color: var(--err); }

/* Buttons */
button, .btn {
  padding: 6px 18px;
  border: 1px solid var(--sep);
  background: var(--bg);
  color: var(--text);
  font-weight: 500;
  font-size: 13px;
  cursor: pointer;
  border-radius: 0;
  margin: 4px;
  font-family: inherit;
}
button:hover { background: #e7e7e7; }
.btn-primary { background: var(--dark-blue); color: white; border-color: var(--dark-blue); font-weight: 600; }
.btn-primary:hover { background: var(--blue); }
.btn-danger { background: var(--problem-bg); color: var(--err); border-color: var(--err); font-weight: 600; }

/* Inputs */
input[type="text"], input[type="number"], textarea {
  padding: 6px 10px;
  border: 1px solid var(--sep);
  border-radius: 0;
  font-size: 13px;
  font-family: inherit;
  width: 100%;
}
input:focus, textarea:focus { border-color: var(--blue); outline: none; }

/* Output */
.output {
  background: var(--bg-white);
  border: 1px solid var(--sep);
  padding: 10px;
  font-family: 'Source Code Pro', 'Consolas', monospace;
  font-size: 12px;
  white-space: pre-wrap;
  word-break: break-all;
  max-height: 400px;
  overflow-y: auto;
  margin: 8px 0;
}

/* Log sub-tabs */
.log-subtab {
  background: none; border: none; padding: 8px 16px; cursor: pointer;
  font-size: 13px; color: var(--soft); border-bottom: 2px solid transparent;
  transition: all 0.15s;
}
.log-subtab:hover { color: var(--text); background: #f0f0f0; }
.log-subtab.active { color: var(--blue); border-bottom-color: var(--blue); font-weight: 600; }
.log-panel { display: none; }
.log-panel.active { display: block; }

/* Log level coloring */
.log-colored .log-err { color: #c0392b; font-weight: 600; }
.log-colored .log-warn { color: #d68910; }
.log-colored .log-info { color: #2c3e50; }
.log-colored .log-debug { color: #7f8c8d; }
.log-colored .log-ts { color: #7f8c8d; }
.log-colored .log-highlight { background: #fff3cd; }

/* Row layout */
.row { display: flex; align-items: center; gap: 8px; margin: 6px 0; flex-wrap: wrap; }
.row label { font-weight: 500; white-space: nowrap; min-width: 100px; }
.row input { flex: 1; min-width: 120px; }

/* Permission list */
.perm-list { border: 1px solid var(--sep); margin: 8px 0; max-height: 200px; overflow-y: auto; }
.perm-row {
  display: flex; align-items: center; padding: 8px 16px;
  background: var(--bg-white); border-bottom: 1px solid var(--sep);
  cursor: pointer;
}
.perm-row:hover { background: #e8f0fe; }
.perm-row.selected { background: var(--blue); color: white; }

/* Tooltip */
[title] { position: relative; }

/* Info box */
.info-box {
  background: var(--info-bg);
  border: 1px solid var(--frame);
  padding: 12px 20px;
  margin: 10px 0;
  border-radius: 0;
  font-size: 13px;
}

/* Spinner */
.spin { display: inline-block; width: 14px; height: 14px;
  border: 2px solid var(--sep); border-top-color: var(--blue);
  border-radius: 50%; animation: spin .6s linear infinite; }
@keyframes spin { to { transform: rotate(360deg); } }

/* Docs toggle */
details { margin: 8px 0; }
details summary { cursor: pointer; font-weight: 600; color: var(--blue); font-size: 13px; }
details summary:hover { text-decoration: underline; }
details .doc-content { padding: 10px; background: var(--bg-white); border: 1px solid var(--sep);
  margin-top: 4px; font-size: 13px; line-height: 1.5; }
details .doc-content code { background: #f2f2f2; padding: 1px 4px; font-family: 'Source Code Pro', monospace; font-size: 12px; }
</style>
</head>
<body>

<div class="titlebar">
  <h1>Qubes Global Admin</h1>
  <span class="ver" id="version">v""" + VERSION + r"""</span>
</div>

<div class="connbar warn" id="connbar">
  <span class="dot d warn" id="conn-dot">&#x25cf;</span>
  <span id="conn-text">Checking connection...</span>
  <span class="vm" id="conn-vm">VM: """ + MANAGED_VM + r"""</span>
  <button onclick="refreshAll()" title="Refresh all data and VM lists" style="background:none;border:1px solid var(--border);border-radius:4px;cursor:pointer;padding:2px 8px;font-size:12px;color:var(--fg);margin-left:8px">&#x21bb; Refresh</button>
  <span id="global-spinner" style="display:none;margin-left:6px" title="Loading...">
    <svg width="16" height="16" viewBox="0 0 16 16" style="animation:spin 1s linear infinite">
      <circle cx="8" cy="8" r="6" stroke="var(--blue)" stroke-width="2" fill="none" stroke-dasharray="28" stroke-dashoffset="8"/>
    </svg>
  </span>
</div>

<div class="main">
  <nav class="sidebar" id="sidebar">
    <button class="tab active" data-page="dashboard" title="Daemon status, service control, panel info">Dashboard</button>
    <button class="tab" data-page="log" title="Daemon, journal, VM, container, and autostart logs — always ready">Logs</button>
    <button class="tab" data-page="vms" title="Manage VMs: connect, authorize, lifecycle, templates">Virtual Machines</button>
    <button class="tab" data-page="execute" title="Run commands in dom0 or inside VMs">Execute</button>
    <button class="tab" data-page="files" title="Transfer files between dom0 and VMs">Files</button>
    <button class="tab" data-page="openclaw" title="OpenClaw multi-agent container management and config">OpenClaw</button>
    <button class="tab" data-page="device" title="Dom0 hardware info and running VMs">This Device</button>
    <button class="tab" data-page="globalcfg" title="Qubes OS global preferences and settings">Global Config</button>
    <button class="tab" data-page="vmtools" title="Standard Qubes tools: firewall, devices, features, tags, services, policies">VM Tools</button>
    <button class="tab" data-page="qvmremote" title="qvm-remote connections, queue management, command history">qvm-remote</button>
    <button class="tab" data-page="backup" title="System and config backups">Backup</button>
    <button class="tab" data-page="policy" title="Restrict command execution per VM pool &#8212; dom0 protection, selective permissions" style="border-top:1px solid var(--border)">Policy Enforcer</button>
  </nav>

  <div class="content">

    <!-- ═══ Dashboard ═══ -->
    <div class="page active" id="page-dashboard">
      <h2 title="Monitor and control the qvm-remote dom0 daemon">Service Dashboard</h2>
      <p class="expl">The qvm-remote daemon runs in dom0 and executes authenticated commands from authorized VMs. Start, stop, or configure it here.</p>

      <div class="card">
        <div class="card-title">Service Status</div>
        <div class="dot-inline" id="svc-status">
          <span class="d warn">&#x25cf;</span> <span>Checking...</span>
        </div>
        <div style="margin-top:4px;font-size:12px;color:var(--soft)" id="svc-version"></div>
        <div class="row" style="margin-top:8px">
          <button class="btn-primary" onclick="svcCtl('start')" title="Start the daemon via systemctl">Start</button>
          <button class="btn-danger" onclick="if(confirm('Stop daemon? VMs cannot run commands until restarted.'))svcCtl('stop')" title="Stop the daemon">Stop</button>
          <button onclick="svcCtl('restart')" title="Restart the daemon (stop + start)">Restart</button>
        </div>
      </div>

      <div class="card">
        <div class="card-title">Autostart</div>
        <p class="expl">When enabled, the daemon starts automatically on every boot via systemd. Authorized VMs can submit commands at all times.</p>
        <div class="dot-inline" id="auto-status">
          <span class="d warn">&#x25cf;</span> <span>Unknown</span>
        </div>
        <div class="row" style="margin-top:8px">
          <button onclick="if(confirm('Enable autostart? Daemon runs on every boot.'))svcCtl('enable')" title="Enable auto-start on boot">Enable</button>
          <button onclick="svcCtl('disable')" title="Disable auto-start">Disable</button>
        </div>
      </div>

      <div class="card">
        <div class="card-title">Queue Health</div>
        <div class="dot-inline" id="queue-status">
          <span class="d warn">&#x25cf;</span> <span>Checking...</span>
        </div>
        <div class="output" id="queue-detail" style="max-height:120px;margin-top:8px;font-size:12px">Loading...</div>
        <div class="row" style="margin-top:8px">
          <button onclick="queueAction('status')" title="Refresh queue counts">Refresh</button>
          <button class="btn-primary" onclick="queueAction('recover')" title="Fail stuck running commands (returns error to waiting clients)">Recover Stuck</button>
          <button class="btn-danger" onclick="if(confirm('Clean ALL queues? Active commands will be lost.'))queueAction('clean')" title="Remove ALL queue files across all VMs">Clean All</button>
          <button onclick="queueAction('debug')" title="Detailed queue dump for troubleshooting">Debug Dump</button>
        </div>
        <div class="output" id="queue-action-output" style="max-height:200px;display:none"></div>
      </div>

      <div class="card">
        <div class="card-title">Configuration</div>
        <details>
          <summary>What is this?</summary>
          <div class="doc-content">
            <code>/etc/qubes/remote.conf</code> lists the VMs that the daemon polls for commands.
            Edit it manually or use the Virtual Machines tab to authorize VMs.
          </div>
        </details>
        <div class="output" id="config-view" style="max-height:150px">Loading...</div>
      </div>

      <div class="card">
        <div class="card-title" title="Admin panel hosting and security information">Admin Panel Security</div>
        <div id="panel-info" style="font-size:12px;line-height:1.8">Loading...</div>
        <button onclick="loadPanelInfo()" style="margin-top:6px;font-size:11px">Refresh</button>
      </div>

      <div class="card">
        <div class="card-title" title="Detect and fix issues with daemon, web server, and VM connectivity">Self-Heal &amp; Diagnostics</div>
        <p class="expl">Click to check all services and automatically restart anything that has failed. The web admin panel can always recover itself and the daemon.</p>
        <div class="row">
          <button class="btn-primary" onclick="doSelfHeal()" title="Check all services and fix any that are down">Run Self-Heal</button>
          <button onclick="doSelfHeal(true)" title="Restart everything regardless of current state">Force Restart All</button>
        </div>
        <div class="output" id="heal-output" style="min-height:60px"></div>
      </div>
    </div>

    <!-- ═══ Execute ═══ -->
    <div class="page" id="page-execute">
      <h2 title="Run commands in dom0 via the authenticated qvm-remote channel">Execute Command in Dom0</h2>
      <p class="expl">Commands are sent from the managed VM to dom0, authenticated with HMAC-SHA256, and executed by the daemon. Output appears below.</p>

      <details>
        <summary>Command examples &amp; documentation</summary>
        <div class="doc-content">
          <strong>Common commands:</strong><br>
          <code>qvm-ls --running</code> -- list running VMs<br>
          <code>xl info | grep total_memory</code> -- Xen memory info<br>
          <code>qvm-prefs work memory 4096</code> -- set VM memory<br>
          <code>qvm-start work</code> / <code>qvm-shutdown --wait work</code> -- VM lifecycle<br>
          <code>systemctl status qubesd</code> -- check qubesd<br>
          <code>qubes-dom0-update --check-only</code> -- check for updates<br>
          <code>qvm-firewall work list</code> -- list firewall rules<br>
          <code>qvm-usb list</code> -- list USB devices<br>
          <br>
          <strong>Timeout:</strong> Maximum seconds before the command is killed (default 300). Increase for long operations like backups or updates.
        </div>
      </details>

      <div class="card">
        <div class="card-title">Command</div>
        <div class="row">
          <input type="text" id="exec-cmd" placeholder="e.g. qvm-ls --running --fields NAME,CLASS,LABEL,MEM"
                 title="Shell command to run in dom0. Press Enter or click Execute."
                 onkeydown="if(event.key==='Enter')doExec()">
        </div>
        <div class="row">
          <button class="btn-primary" onclick="doExec()" title="Execute the command in dom0">Execute</button>
          <label style="min-width:auto" title="Maximum seconds before the command is killed">Timeout:</label>
          <input type="number" id="exec-timeout" value="300" style="width:80px;flex:none"
                 title="Increase for long operations (backups, updates)">
          <span style="font-size:12px">sec</span>
        </div>
      </div>

      <h3>Output</h3>
      <div class="dot-inline" id="exec-status"><span class="d ok">&#x25cf;</span> <span>Ready</span></div>
      <div class="output" id="exec-output" style="min-height:200px"></div>

      <h2 title="Run a command inside a VM via qvm-run" style="margin-top:20px">Run in VM</h2>
      <p class="expl">Execute commands inside any VM using qvm-run. Supports all flags: --pass-io, --no-gui, --user, --dispvm, --service, --no-autostart.</p>
      <div class="card">
        <div class="card-title">qvm-run</div>
        <div class="row">
          <label title="Target VM (or base AppVM for DispVM)">VM:</label>
          <select id="vmrun-vm" class="vm-selector" style="width:180px" title="Select target VM"></select>
          <label style="min-width:auto"><input type="checkbox" id="vmrun-dispvm"> DispVM</label>
        </div>
        <div class="row">
          <input type="text" id="vmrun-cmd" placeholder="e.g. uname -a" title="Command to run in the VM" onkeydown="if(event.key==='Enter')doVmRun()">
        </div>
        <div class="row" style="flex-wrap:wrap;gap:8px">
          <label style="min-width:auto" title="Pass stdin/stdout/stderr"><input type="checkbox" id="vmrun-passio" checked> --pass-io</label>
          <label style="min-width:auto" title="No GUI forwarding"><input type="checkbox" id="vmrun-nogui" checked> --no-gui</label>
          <label style="min-width:auto" title="Don't auto-start the VM"><input type="checkbox" id="vmrun-noauto"> --no-autostart</label>
          <label style="min-width:auto" title="Start RPC service"><input type="checkbox" id="vmrun-service"> --service</label>
          <label style="min-width:auto" title="Run as user">--user:</label>
          <input type="text" id="vmrun-user" placeholder="(default)" style="width:100px;flex:none" title="Run command as this user">
          <label style="min-width:auto">Timeout:</label>
          <input type="number" id="vmrun-timeout" value="120" style="width:70px;flex:none">
          <span style="font-size:12px">sec</span>
        </div>
        <div class="row" style="margin-top:6px">
          <button class="btn-primary" onclick="doVmRun()" title="Execute command in the selected VM">Run in VM</button>
          <button onclick="doVmRunApi()" title="Run without streaming (POST /api/vm-run)">Run (no stream)</button>
        </div>
      </div>
      <div class="dot-inline" id="vmrun-status"><span class="d ok">&#x25cf;</span> <span>Ready</span></div>
      <div class="output" id="vmrun-output" style="min-height:150px"></div>
    </div>

    <!-- ═══ VMs ═══ -->
    <div class="page" id="page-vms">
      <h2 title="Manage which VMs can send commands to dom0">Virtual Machines</h2>
      <p class="expl">Each VM needs a registered HMAC-SHA256 key to authenticate commands. Only authorized VMs listed here can execute anything in dom0.</p>

      <details>
        <summary>How to authorize a VM</summary>
        <div class="doc-content">
          1. In the VM, run: <code>qvm-remote key gen</code><br>
          2. Copy the 64-character hex key<br>
          3. Paste it below with the VM name and click Authorize<br>
          4. Test: <code>qvm-remote ping</code> from the VM
        </div>
      </details>

      <h3 title="VMs with registered keys in /etc/qubes/remote.d/">Authorized VMs</h3>
      <div class="perm-list" id="vm-list"></div>
      <div class="row">
        <button onclick="loadVmKeys()" title="Reload the list of authorized VMs">Refresh</button>
        <button class="btn-danger" onclick="revokeVm()" title="Remove the selected VM's key">Revoke Selected</button>
      </div>

      <h3 title="Register a new VM with its HMAC-SHA256 key">Authorize New VM</h3>
      <div class="card">
        <div class="row">
          <label title="The Qubes VM name (e.g. work, personal)">VM name:</label>
          <select id="auth-vm" class="vm-selector" style="width:180px" title="Name of the VM to authorize"></select>
        </div>
        <div class="row">
          <label title="64-character hex key from 'qvm-remote key show'">Key:</label>
          <input type="text" id="auth-key" placeholder="64-character hex key"
                 title="Paste the 64-char hex key generated by 'qvm-remote key gen' in the VM">
          <button class="btn-primary" onclick="authorizeVm()" title="Register this VM+key pair">Authorize</button>
        </div>
      </div>

      <h3 title="One-step connection setup: authorize key + add to config + init VM dirs">Connect / Disconnect VM</h3>
      <details>
        <summary>How connect/disconnect works</summary>
        <div class="doc-content">
          <strong>Connect:</strong> Authorize the VM's key, add it to the config, initialize queue dirs, and signal the daemon.<br>
          If no key is provided, it auto-fetches from the VM (the VM must be running and have run <code>qvm-remote key gen</code>).<br><br>
          <strong>Disconnect:</strong> Revokes the key, removes from config, and cleans the VM's queue. The daemon stops polling it.
        </div>
      </details>
      <div class="card">
        <div class="row">
          <label title="VM name to connect">VM:</label>
          <select id="conn-vm-name" class="vm-selector" style="width:180px" title="Name of the VM to connect/disconnect"></select>
          <label title="Optional: hex key (auto-fetched if empty)" style="min-width:auto">Key:</label>
          <input type="text" id="conn-vm-key" placeholder="(auto-fetch from VM)" title="64-char hex key. Leave empty to auto-fetch from the VM.">
        </div>
        <div class="row">
          <button class="btn-primary" onclick="connectVm()" title="Authorize + add to config + init VM dirs">Connect</button>
          <button class="btn-danger" onclick="if(confirm('Disconnect this VM? Its key will be revoked and queue cleaned.'))disconnectVm()" title="Revoke key + remove from config + clean queue">Disconnect</button>
          <button onclick="loadDaemonStatus()" title="Show full daemon status report">Daemon Status</button>
        </div>
        <div class="output" id="conn-output" style="max-height:200px;min-height:60px"></div>
      </div>

      <h3 title="Start, stop, or check VMs from here">VM Lifecycle</h3>
      <div class="card">
        <div class="row">
          <label title="Target VM name">VM:</label>
          <select id="lc-vm" class="vm-selector" style="width:200px" title="Which VM to control"></select>
          <button class="btn-primary" onclick="vmCtl('start')" title="Start the VM (qvm-start)">Start</button>
          <button class="btn-danger" onclick="if(confirm('Shutdown this VM?'))vmCtl('stop')" title="Graceful shutdown (qvm-shutdown --wait)">Shutdown</button>
          <button onclick="vmCtl('check')" title="Check if VM is running">Check</button>
        </div>
      </div>
      <div class="output" id="vm-output" style="min-height:60px"></div>

      <h3 title="One-click setup: install client, generate key, authorize, test">Quick VM Setup</h3>
      <p class="expl">Select a VM and click Setup to automatically install the qvm-remote client, generate a key, authorize it in dom0, and verify the connection.</p>
      <div class="card">
        <div class="row">
          <label>VM:</label>
          <select id="setup-vm" class="vm-selector" style="width:200px" title="VM to set up for qvm-remote"></select>
          <button class="btn-primary" onclick="doVmSetup()" title="Install client, generate key, authorize, test">Setup VM</button>
        </div>
        <div class="output" id="setup-output" style="min-height:60px"></div>
      </div>

      <h3 title="Install qvm-remote client into a template (all AppVMs inherit it)">Install Client in Template</h3>
      <p class="expl">Push the qvm-remote client into a template VM. After shutdown, all AppVMs based on the template will have the client on next boot.</p>
      <div class="card">
        <div class="row">
          <label>Template:</label>
          <select id="tpl-install-vm" class="vm-selector" style="width:200px" title="Template to install client into"></select>
          <button class="btn-primary" onclick="doTemplateInstall()" title="Install qvm-remote client and shut down template">Install &amp; Shutdown</button>
        </div>
        <div class="output" id="tpl-install-output" style="min-height:60px"></div>
      </div>
    </div>

    <!-- ═══ Files ═══ -->
    <div class="page" id="page-files">
      <h2 title="Transfer files between dom0, the managed VM, and other VMs">File Transfers</h2>
      <p class="expl">Use qvm-run --pass-io to pipe files between VMs through dom0. All transfers are logged.</p>

      <details>
        <summary>File transfer documentation</summary>
        <div class="doc-content">
          <strong>Push (dom0 &rarr; VM):</strong> <code>cat /dom0/file | qvm-run --pass-io VM 'cat &gt; /vm/file'</code><br>
          <strong>Pull (VM &rarr; dom0):</strong> <code>qvm-run --pass-io VM 'cat /vm/file' &gt; /dom0/file</code><br>
          <strong>VM-to-VM:</strong> pipes through dom0 using two qvm-run commands<br>
          <br>
          Paths must be absolute. Binary files are supported.
        </div>
      </details>

      <div class="card">
        <div class="card-title" title="Copy a file from dom0 into a VM">Push File: Dom0 &rarr; VM</div>
        <div class="row">
          <label title="VM to receive the file">Target VM:</label>
          <select id="push-vm" class="vm-selector" style="width:180px" title="Destination VM name"></select>
        </div>
        <div class="row">
          <label title="Path to the file in dom0">Dom0 path:</label>
          <input type="text" id="push-src" placeholder="/tmp/file" title="Source file in dom0">
          <label title="Destination path inside the VM" style="min-width:auto">VM path:</label>
          <input type="text" id="push-dst" placeholder="/tmp/file" title="Where to write in the VM">
          <button class="btn-primary" onclick="filePush()" title="Send the file">Push</button>
        </div>
      </div>

      <div class="card">
        <div class="card-title" title="Fetch a file from a VM into dom0">Pull File: VM &rarr; Dom0</div>
        <div class="row">
          <label title="VM containing the file">Source VM:</label>
          <select id="pull-vm" class="vm-selector" style="width:180px" title="Source VM name"></select>
          <label title="Path inside the VM" style="min-width:auto">VM path:</label>
          <input type="text" id="pull-src" placeholder="/path/in/vm" title="File to pull from the VM">
        </div>
        <div class="row">
          <label title="Where to save in dom0">Dom0 dest:</label>
          <input type="text" id="pull-dst" placeholder="/tmp/" title="Destination in dom0">
          <button class="btn-primary" onclick="filePull()" title="Fetch the file">Pull</button>
        </div>
      </div>
      <div class="output" id="file-output" style="min-height:60px"></div>
    </div>

    <!-- ═══ Backup ═══ -->
    <div class="page" id="page-backup">
      <h2 title="Create backups of your Qubes system and qvm-remote configuration">Backup &amp; Recovery</h2>
      <p class="expl">Back up qvm-remote configuration or trigger a full Qubes system backup.</p>

      <details>
        <summary>Backup documentation</summary>
        <div class="doc-content">
          <strong>System backup:</strong> Uses <code>qvm-backup</code> to create an encrypted backup of all VMs.<br>
          <strong>Config backup:</strong> Archives <code>/etc/qubes/remote.conf</code>, VM keys, and the daemon log.<br>
          <br>
          System backups can take hours for large VM sets. Increase the timeout accordingly.
        </div>
      </details>

      <h3 title="Trigger a full Qubes OS backup (qvm-backup)">Dom0 System Backup</h3>
      <div class="card">
        <div class="row">
          <label title="Directory or device for the backup">Destination:</label>
          <input type="text" id="bak-dest" value="/mnt/backup/" title="Path in dom0">
          <button onclick="checkBackup()" title="List existing backups and check disk space">Check</button>
          <button class="btn-primary" onclick="if(confirm('Start full Qubes backup? This may take hours.'))startBackup()"
                  title="Begin a full backup">Start Backup</button>
        </div>
      </div>
      <div class="output" id="bak-output" style="min-height:80px"></div>
    </div>

    <!-- ═══ Log ═══ -->
    <div class="page" id="page-log">
      <h2 title="View daemon logs, systemd journals, VM logs, container logs, and autostart logs">Logs</h2>
      <div class="row" style="gap:0;margin-bottom:12px;border-bottom:2px solid var(--border)">
        <button class="log-subtab active" data-logtab="daemon" onclick="switchLogTab('daemon')" title="qvm-remote-dom0 command log">Daemon</button>
        <button class="log-subtab" data-logtab="journal" onclick="switchLogTab('journal')" title="Systemd journal for all services">Journal</button>
        <button class="log-subtab" data-logtab="container" onclick="switchLogTab('container')" title="Container logs from VMs (podman/docker)">Containers</button>
        <button class="log-subtab" data-logtab="autostart" onclick="switchLogTab('autostart')" title="Last login autostart script output">Autostart</button>
        <button class="log-subtab" data-logtab="configs" onclick="switchLogTab('configs')" title="Inspect dom0 configuration files">Config Files</button>
        <span style="flex:1"></span>
        <label style="min-width:auto;font-size:11px;color:var(--soft)" title="Auto-refresh logs every 10 seconds"><input type="checkbox" id="log-autorefresh" onchange="toggleLogAutoRefresh()"> Auto-refresh</label>
      </div>

      <!-- Daemon sub-tab -->
      <div class="log-panel active" id="logpanel-daemon">
        <div class="row" style="margin-bottom:8px">
          <button class="btn-primary" onclick="loadLog()" title="Reload the full daemon log">Refresh</button>
          <label style="min-width:auto">VM:</label>
          <select id="log-vm" class="vm-selector" style="width:140px;flex:none" title="Filter log to a specific VM"><option value="">(all VMs)</option></select>
          <button onclick="loadVmLog()" title="Show only commands from this VM">Filter</button>
          <label style="min-width:auto">Lines:</label>
          <select id="log-lines" style="width:80px;flex:none"><option value="50">50</option><option value="100" selected>100</option><option value="200">200</option><option value="500">500</option></select>
          <label style="min-width:auto">Search:</label>
          <input type="text" id="log-search" placeholder="grep..." style="width:140px;flex:none" onkeydown="if(event.key==='Enter')filterLogOutput()">
          <button onclick="filterLogOutput()" title="Filter current output by keyword">Go</button>
        </div>
        <div class="output log-colored" id="log-output" style="min-height:300px;max-height:600px">Loading...</div>
      </div>

      <!-- Journal sub-tab -->
      <div class="log-panel" id="logpanel-journal">
        <div class="row" style="margin-bottom:8px">
          <label style="min-width:auto">Unit:</label>
          <select id="journal-unit" style="width:200px;flex:none">
            <option value="qvm-remote-dom0">qvm-remote-dom0</option>
            <option value="qubes-global-admin-web">qubes-global-admin-web</option>
            <option value="qubes-admin-watchdog">qubes-admin-watchdog</option>
            <option value="qubesd">qubesd</option>
          </select>
          <label style="min-width:auto">Lines:</label>
          <select id="journal-lines" style="width:80px;flex:none"><option value="50">50</option><option value="100" selected>100</option><option value="200">200</option><option value="500">500</option></select>
          <label style="min-width:auto">Since:</label>
          <select id="journal-since" style="width:120px;flex:none">
            <option value="">(all)</option>
            <option value="5 minutes ago">5 min</option>
            <option value="1 hour ago" selected>1 hour</option>
            <option value="today">Today</option>
            <option value="yesterday">Yesterday</option>
          </select>
          <button class="btn-primary" onclick="loadJournal()" title="Fetch journal entries">Refresh</button>
        </div>
        <div class="output log-colored" id="journal-output" style="min-height:300px;max-height:600px">Select a unit and click Refresh</div>
      </div>

      <!-- Container sub-tab -->
      <div class="log-panel" id="logpanel-container">
        <div class="row" style="margin-bottom:8px">
          <label style="min-width:auto">VM:</label>
          <select id="clog-vm" class="vm-selector" style="width:140px;flex:none" title="VM running containers" onchange="loadContainerSuggestions()"><option value="">(select VM)</option></select>
          <label style="min-width:auto">Container:</label>
          <select id="clog-name-sel" style="width:180px;flex:none"><option value="">(select or type)</option></select>
          <input type="text" id="clog-name" placeholder="or type name..." style="width:140px;flex:none" title="Container name">
          <label style="min-width:auto">Lines:</label>
          <select id="clog-lines" style="width:80px;flex:none"><option value="50" selected>50</option><option value="100">100</option><option value="200">200</option></select>
          <button class="btn-primary" onclick="getContainerLogs()" title="Fetch container logs">Refresh</button>
        </div>
        <div class="output log-colored" id="clog-output" style="min-height:300px;max-height:600px">Select a VM and container</div>
      </div>

      <!-- Autostart sub-tab -->
      <div class="log-panel" id="logpanel-autostart">
        <div class="row" style="margin-bottom:8px">
          <button class="btn-primary" onclick="loadAutoLog()" title="Load the last login autostart script output">Refresh</button>
          <span style="font-size:11px;color:var(--soft)">From <code>/tmp/dom0-admin-autostart.log</code></span>
        </div>
        <div class="output log-colored" id="autolog-output" style="min-height:300px;max-height:600px">Loading...</div>
      </div>

      <!-- Config files sub-tab -->
      <div class="log-panel" id="logpanel-configs">
        <div class="row" style="margin-bottom:8px">
          <label style="min-width:auto">File:</label>
          <select id="config-file-sel" style="flex:1" onchange="loadConfigFile()">
            <option value="">(select a config file)</option>
          </select>
          <button class="btn-primary" onclick="loadConfigFile()" title="Reload selected file">Refresh</button>
          <button onclick="loadConfigFileList()" title="Refresh the file list">List Files</button>
        </div>
        <div style="font-size:11px;color:var(--soft);margin-bottom:6px" id="config-file-desc"></div>
        <div class="output" id="config-file-output" style="min-height:300px;max-height:600px">Select a config file to inspect</div>
      </div>
    </div>

    <!-- ═══ Device ═══ -->
    <div class="page" id="page-device">
      <h2 title="System information about dom0">This Device</h2>
      <p class="expl">Hardware and software information about your Qubes system.</p>

      <div class="card">
        <div class="card-title">Dom0 Information</div>
        <div class="output" id="dev-info">Loading...</div>
      </div>

      <h3 title="qvm-ls output showing running VMs">Running VMs</h3>
      <div class="output" id="dev-vms">Loading...</div>
      <button onclick="loadDevice()" title="Re-gather system information">Refresh</button>
    </div>

    <!-- ═══ OpenClaw ═══ -->
    <div class="page" id="page-openclaw">
      <h2 title="Manage OpenClaw multi-agent AI containers">OpenClaw</h2>
      <p class="expl">Manage OpenClaw Cursor proxy and gateway containers. Connect multiple AI agent instances across Qubes VMs.</p>

      <details>
        <summary>OpenClaw architecture &amp; documentation</summary>
        <div class="doc-content">
          <strong>Architecture:</strong><br>
          &bull; <code>openclaw-cursor proxy</code> (port 32125) -- OpenAI-compatible API proxy<br>
          &bull; <code>openclaw gateway</code> (port 18789) -- Dashboard + WebSocket for agents<br>
          &bull; VMs connect via <code>qubes.ConnectTCP</code> (qrexec tunnels, no network routing)<br>
          <br>
          <strong>Quick start:</strong><br>
          1. Start containers: click Start below<br>
          2. In client VMs: <code>bash client-connect.sh openclaw-vm</code><br>
          3. Test: <code>curl http://localhost:32125/health</code><br>
          <br>
          <strong>Security:</strong> Traffic goes through Xen vchan (not network). Dom0 policy whitelists specific VMs and ports.
        </div>
      </details>

      <div class="card">
        <div class="card-title">Container Status</div>
        <div class="dot-inline" id="oc-proxy-status">
          <span class="d warn">&#x25cf;</span> <span>Proxy: checking...</span>
        </div>
        <div class="dot-inline" id="oc-gw-status" style="margin-top:4px">
          <span class="d warn">&#x25cf;</span> <span>Gateway: checking...</span>
        </div>
        <div id="oc-containers" style="margin-top:8px;font-size:12px;color:var(--soft)"></div>
      </div>

      <div class="card">
        <div class="card-title">Controls</div>
        <div class="row">
          <button class="btn-primary" onclick="ocCtl('start')" title="Start OpenClaw containers (docker/podman compose up)">Start</button>
          <button class="btn-danger" onclick="if(confirm('Stop OpenClaw containers?'))ocCtl('stop')" title="Stop all OpenClaw containers">Stop</button>
          <button onclick="ocCtl('restart')" title="Restart containers">Restart</button>
          <button onclick="ocCtl('logs')" title="Show recent container logs">View Logs</button>
          <button onclick="loadOpenClaw()" title="Refresh status">Refresh</button>
        </div>
      </div>

      <h3 title="Control OpenClaw containers running inside a specific VM">VM Container Controls</h3>
      <details>
        <summary>How OpenClaw runs in VMs</summary>
        <div class="doc-content">
          OpenClaw runs as containers (podman/docker) or systemd user services inside VMs.<br>
          The proxy listens on <code>:32125</code> (OpenAI-compatible API).<br>
          The gateway listens on <code>:18789</code> (dashboard + WebSocket).<br>
          Other VMs connect via <code>qubes.ConnectTCP</code> qrexec tunnels.<br><br>
          <strong>Container paths searched:</strong> <code>~/qubes-claw/openclaw</code>, <code>~/openclaw-cursor</code>
        </div>
      </details>
      <div class="card">
        <div class="row">
          <label title="VM where OpenClaw runs">VM:</label>
          <select id="ocvm-name" class="vm-selector" style="width:180px" title="Target VM name"></select>
          <button onclick="ocVmCtl('status')" title="Check proxy and gateway health inside the VM">Status</button>
          <button class="btn-primary" onclick="ocVmCtl('start')" title="Start containers or systemd services in the VM">Start</button>
          <button class="btn-danger" onclick="if(confirm('Stop OpenClaw in this VM?'))ocVmCtl('stop')" title="Stop all OpenClaw services in the VM">Stop</button>
          <button onclick="ocVmCtl('logs')" title="Fetch container/service logs from the VM">Logs</button>
        </div>
        <div class="output" id="ocvm-output" style="min-height:80px"></div>
      </div>

      <h3 title="View logs from a specific container (in dom0 or a VM)">Container Logs</h3>
      <div class="card">
        <div class="row">
          <label title="Container name">Container:</label>
          <input type="text" id="clog-name" placeholder="openclaw-cursor-proxy" title="Container name (e.g. openclaw-cursor-proxy)">
          <label style="min-width:auto" title="If in a VM, enter name">VM:</label>
          <select id="clog-vm" class="vm-selector" style="width:180px" title="Leave empty for dom0 containers, or select VM name"><option value="">(dom0)</option></select>
          <label style="min-width:auto">Lines:</label>
          <input type="number" id="clog-lines" value="50" style="width:60px;flex:none">
          <button class="btn-primary" onclick="getContainerLogs()" title="Fetch logs">Get Logs</button>
        </div>
        <div class="output" id="clog-output" style="max-height:250px"></div>
      </div>

      <h3>ConnectTCP Policy</h3>
      <div class="info-box">
        <strong>qubes.ConnectTCP</strong> tunnels TCP connections between VMs through dom0 qrexec — no network routing.<br>
        Policy file: <code>/etc/qubes/policy.d/50-openclaw.policy</code><br>
        Use the <strong>VM Tools</strong> tab &rarr; <strong>Policies</strong> section to view or edit.
      </div>

      <h3 title="OpenClaw engine, ports, paths, and timeout configuration">Configuration</h3>
      <div class="card">
        <div class="row" style="flex-wrap:wrap;gap:8px">
          <label style="min-width:auto">Engine:</label>
          <select id="oc-engine" style="width:120px;padding:4px 8px;border:1px solid var(--border);border-radius:4px;background:var(--card);color:var(--fg)" title="Container engine preference">
            <option value="auto">auto</option><option value="podman">podman</option><option value="docker">docker</option>
          </select>
          <label style="min-width:auto">Proxy port:</label>
          <input type="number" id="oc-proxy-port" value="32125" style="width:80px;flex:none" title="OpenClaw proxy port">
          <label style="min-width:auto">Gateway port:</label>
          <input type="number" id="oc-gw-port" value="18789" style="width:80px;flex:none" title="OpenClaw gateway port">
        </div>
        <div class="row" style="margin-top:6px">
          <label style="min-width:auto">Compose paths (comma-separated):</label>
          <input type="text" id="oc-paths" value="~/qubes-claw/openclaw, ~/openclaw-cursor" title="Search paths for docker-compose files">
        </div>
        <div class="row" style="margin-top:6px">
          <button class="btn-primary" onclick="saveOcConfig()" title="Save OpenClaw configuration">Save Config</button>
          <button onclick="loadOcConfig()" title="Reload configuration from file">Reload</button>
        </div>
      </div>

      <div class="output" id="oc-output" style="min-height:100px"></div>
    </div>

    <!-- ═══ Global Config ═══ -->
    <div class="page" id="page-globalcfg">
      <h2 title="Qubes OS global preferences — defaults for VMs, network, kernel, updates">Global Configuration</h2>
      <p class="expl">System-wide Qubes preferences that apply to all VMs. Changes here affect defaults for new VMs and system behavior.</p>

      <details>
        <summary>Global preferences documentation</summary>
        <div class="doc-content">
          <code>qubes-prefs</code> controls system-wide defaults:<br>
          <code>default_template</code> — Template used for new AppVMs<br>
          <code>default_netvm</code> — Default network VM<br>
          <code>default_dispvm</code> — Default disposable VM template<br>
          <code>default_kernel</code> — Default kernel for VMs<br>
          <code>clockvm</code> — VM that provides time to dom0<br>
          <code>updatevm</code> — VM used for dom0 updates<br>
          <code>default_pool</code> — Default storage pool<br>
        </div>
      </details>

      <div class="card">
        <div class="card-title">System Preferences</div>
        <div class="output" id="gp-prefs" style="max-height:250px">Loading...</div>
        <button onclick="loadGlobalPrefs()" title="Reload global preferences">Refresh</button>
      </div>

      <div class="card">
        <div class="card-title">Edit Preference</div>
        <div class="row">
          <label title="Preference name (e.g. default_netvm)">Property:</label>
          <select id="gp-prop" title="qubes-prefs property name" style="width:180px"><option value="">(select property)</option><option value="clockvm">clockvm</option><option value="default_template">default_template</option><option value="default_fw_netvm">default_fw_netvm</option><option value="default_netvm">default_netvm</option><option value="default_kernel">default_kernel</option><option value="default_pool">default_pool</option><option value="updatevm">updatevm</option></select>
          <label title="New value" style="min-width:auto">Value:</label>
          <input type="text" id="gp-val" placeholder="sys-firewall" title="New value for the property">
          <button class="btn-primary" onclick="setGlobalPref()" title="Apply the preference change">Set</button>
        </div>
      </div>

      <h3>VM Preferences</h3>
      <div class="card">
        <div class="row">
          <label title="VM name">VM:</label>
          <select id="vp-vm" class="vm-selector" style="width:180px" title="Target VM name"></select>
          <button onclick="loadVmPrefs()" title="Show all properties for this VM">Show</button>
        </div>
        <div class="row">
          <label title="Property to set">Prop:</label>
          <select id="vp-prop" title="Property name (e.g. memory, vcpus, netvm)" style="width:180px"><option value="">(select property)</option><option>autostart</option><option>debug</option><option>default_dispvm</option><option>default_user</option><option>include_in_backups</option><option>ip</option><option>kernel</option><option>kernelopts</option><option>label</option><option>mac</option><option>maxmem</option><option>memory</option><option>netvm</option><option>provides_network</option><option>qrexec_timeout</option><option>template</option><option>template_for_dispvms</option><option>vcpus</option><option>virt_mode</option></select>
          <label style="min-width:auto">Value:</label>
          <input type="text" id="vp-val" placeholder="4096" title="New value">
          <button class="btn-primary" onclick="setVmPref()" title="Set the property value">Set</button>
        </div>
        <div class="output" id="vp-output" style="max-height:200px"></div>
      </div>

      <h3 title="Xen hypervisor information">Xen Hypervisor</h3>
      <div class="card">
        <button onclick="loadXen()" title="Load Xen hypervisor details (xl info, xl list, xl uptime)">Load Xen Info</button>
        <div class="output" id="xen-output" style="max-height:300px"></div>
      </div>

      <h3 title="Installed template VMs">Templates</h3>
      <div class="card">
        <button onclick="loadTemplates()" title="List installed template VMs">List Installed</button>
        <div class="output" id="tpl-output" style="max-height:200px"></div>
      </div>

      <h3 title="Check for dom0 updates">Dom0 Updates</h3>
      <div class="card">
        <div class="row">
          <button onclick="dom0Update('check')" title="Check if updates are available (no changes)">Check Updates</button>
          <button class="btn-danger" onclick="if(confirm('Apply dom0 updates? This may reboot Xen.'))dom0Update('update')" title="Download and install updates">Apply Updates</button>
        </div>
        <div class="output" id="upd-output" style="max-height:150px"></div>
      </div>
    </div>

    <!-- ═══ Advanced ═══ -->
    <div class="page" id="page-vmtools">
      <h2 title="Standard Qubes OS management tools">VM Tools</h2>
      <p class="expl">Standard Qubes OS tools for VM firewalls, device assignment, qrexec features, tags, services, and policies. These are also available in the native Qubes Global Config app.</p>

      <h3 title="Manage VM firewall rules (qvm-firewall)">Firewall</h3>
      <details>
        <summary>Firewall documentation</summary>
        <div class="doc-content">
          <code>qvm-firewall VM list</code> — Show current rules<br>
          <code>qvm-firewall VM add accept proto=tcp dstports=443</code> — Allow HTTPS<br>
          <code>qvm-firewall VM add accept dsthost=10.0.0.0/8</code> — Allow LAN<br>
          <code>qvm-firewall VM add drop</code> — Block everything (last rule)<br>
          <code>qvm-firewall VM reset</code> — Reset to default policy<br>
          Default policy is <strong>drop</strong>. Rules are evaluated top to bottom.
        </div>
      </details>
      <div class="card">
        <div class="row">
          <label>VM:</label>
          <select id="fw-vm" class="vm-selector" style="width:180px" title="VM to manage firewall for"></select>
          <button onclick="loadFirewall()" title="List firewall rules">List Rules</button>
          <button class="btn-danger" onclick="if(confirm('Reset firewall to defaults?'))resetFirewall()" title="Reset to default rules">Reset</button>
        </div>
        <div class="row">
          <label>Add rule:</label>
          <input type="text" id="fw-rule" placeholder="accept proto=tcp dstports=443" title="Rule: action [opts] e.g. 'accept dsthost=10.0.0.0/8'">
          <button class="btn-primary" onclick="addFirewallRule()" title="Add the rule">Add</button>
        </div>
        <div class="output" id="fw-output" style="max-height:200px"></div>
      </div>

      <h3 title="USB, PCI, block, and microphone devices">Devices</h3>
      <details>
        <summary>Device documentation</summary>
        <div class="doc-content">
          <code>qvm-usb list</code> / <code>qvm-pci list</code> / <code>qvm-block list</code><br>
          <code>qvm-usb attach VM BACKEND:PORT</code> — Attach USB device to VM<br>
          <code>qvm-usb detach VM BACKEND:PORT</code> — Detach<br>
          PCI devices require VM restart. USB devices can be hot-plugged.
        </div>
      </details>
      <div class="card">
        <div class="row">
          <button onclick="loadDevices('usb')" title="List USB devices">USB</button>
          <button onclick="loadDevices('pci')" title="List PCI devices">PCI</button>
          <button onclick="loadDevices('block')" title="List block devices">Block</button>
          <button onclick="loadDevices('mic')" title="List microphone devices">Mic</button>
        </div>
        <div class="row">
          <label>VM:</label>
          <select id="dev-ctl-vm" class="vm-selector" style="width:180px" title="VM for attach/detach"></select>
          <label style="min-width:auto">Port:</label>
          <input type="text" id="dev-ctl-port" placeholder="sys-usb:2-1" title="Backend:port identifier">
          <button class="btn-primary" onclick="deviceCtl('attach')" title="Attach device to VM">Attach</button>
          <button class="btn-danger" onclick="deviceCtl('detach')" title="Detach device from VM">Detach</button>
        </div>
        <div class="output" id="dev-ctl-output" style="max-height:200px"></div>
      </div>

      <h3 title="qvm-features: get/set VM features">Features</h3>
      <div class="card">
        <div class="row">
          <label>VM:</label>
          <select id="feat-vm" class="vm-selector" style="width:180px" title="VM name"></select>
          <button onclick="loadFeatures()" title="List all features">List</button>
          <label style="min-width:auto">Feature:</label>
          <input type="text" id="feat-name" list="feat-name-dl" placeholder="gui" title="Feature name" style="width:160px">
          <datalist id="feat-name-dl"><option value="gui"><option value="gui-default-allow-utf8-titles"><option value="internal"><option value="os-distribution"><option value="os-eol"><option value="os-version"><option value="qrexec"><option value="servicevm"><option value="supported-service.qubes-update-check"><option value="updates-available"></datalist>
          <label style="min-width:auto">Value:</label>
          <input type="text" id="feat-val" placeholder="1" title="Feature value">
          <button class="btn-primary" onclick="setFeature()" title="Set feature value">Set</button>
        </div>
        <div class="output" id="feat-output" style="max-height:150px"></div>
      </div>

      <h3 title="qvm-tags: manage VM tags">Tags</h3>
      <div class="card">
        <div class="row">
          <label>VM:</label>
          <select id="tag-vm" class="vm-selector" style="width:180px" title="VM name"></select>
          <button onclick="loadTags()" title="List tags">List</button>
          <label style="min-width:auto">Tag:</label>
          <input type="text" id="tag-name" list="tag-name-dl" placeholder="my-tag" title="Tag name" style="width:160px">
          <datalist id="tag-name-dl"><option value="audiovm-dom0"><option value="created-by-dom0"><option value="guivm-dom0"><option value="anon-gateway"><option value="anon-workstation"><option value="whonix-updatevm"></datalist>
          <button class="btn-primary" onclick="modTag('add')" title="Add tag">Add</button>
          <button class="btn-danger" onclick="modTag('del')" title="Remove tag">Remove</button>
        </div>
        <div class="output" id="tag-output" style="max-height:100px"></div>
      </div>

      <h3 title="qvm-service: manage VM services">Services</h3>
      <div class="card">
        <div class="row">
          <label>VM:</label>
          <select id="svc-vm" class="vm-selector" style="width:180px" title="VM name"></select>
          <button onclick="loadServices()" title="List services">List</button>
          <label style="min-width:auto">Service:</label>
          <input type="text" id="svc-name" list="svc-name-dl" placeholder="qubes-update-check" title="Service name" style="width:180px">
          <datalist id="svc-name-dl"><option value="crond"><option value="cups"><option value="meminfo-writer"><option value="network-manager"><option value="qubes-firewall"><option value="qubes-network"><option value="qubes-update-check"><option value="qubes-updates-proxy"></datalist>
          <button class="btn-primary" onclick="modService('enable')" title="Enable service">Enable</button>
          <button class="btn-danger" onclick="modService('disable')" title="Disable service">Disable</button>
          <button onclick="modService('default')" title="Reset to default">Default</button>
        </div>
        <div class="output" id="svc-output" style="max-height:150px"></div>
      </div>

      <h3 title="Dom0 qrexec policies in /etc/qubes/policy.d/">Qrexec Policies</h3>
      <details>
        <summary>Policy documentation</summary>
        <div class="doc-content">
          Policies in <code>/etc/qubes/policy.d/</code> control inter-VM communication.<br>
          <code>qubes.ConnectTCP</code> — TCP forwarding between VMs<br>
          <code>qubes.Filecopy</code> — File copy between VMs<br>
          <code>qubes.ClipboardPaste</code> — Clipboard sharing<br>
          Files are named <code>NN-name.policy</code> (lower number = higher priority).
        </div>
      </details>
      <div class="card">
        <div class="row">
          <button onclick="loadPolicies()" title="List all policy files">List Policy Files</button>
          <label style="min-width:auto">File:</label>
          <select id="pol-name" title="Policy filename" style="width:220px"><option value="">(load list first)</option></select>
          <button onclick="readPolicy()" title="Read the policy file contents">Read</button>
        </div>
        <div class="output" id="pol-output" style="max-height:200px"></div>
      </div>
    </div>

    <!-- ═══ qvm-remote ═══ -->
    <div class="page" id="page-qvmremote">
      <h2 title="qvm-remote connection management, queue status, and command history">qvm-remote</h2>
      <p class="expl">Manage qvm-remote connections between dom0 and VMs. Monitor queue health, view command history, and audit file transfers.</p>

      <div class="card">
        <div class="card-title" title="All authorized VMs with connection health and permission levels">Connection Map</div>
        <div id="qr-conn-map" style="font-size:12px">Loading...</div>
        <button onclick="loadConnMap()" style="margin-top:6px;font-size:11px">Refresh</button>
      </div>

      <div class="card">
        <div class="card-title" title="Per-VM queue status and recovery">Queue Management</div>
        <div id="qr-queue" style="font-size:12px">Loading...</div>
        <div class="row" style="margin-top:6px">
          <button onclick="loadQrQueue()" title="Refresh queue status">Refresh</button>
          <button onclick="qrQueueAction('recover')" title="Recover stuck commands">Recover Stuck</button>
          <button onclick="qrQueueAction('clean')" title="Clean all queues">Clean All</button>
          <button onclick="qrQueueAction('debug')" title="Debug dump">Debug</button>
        </div>
        <div class="output" id="qr-queue-output" style="max-height:200px"></div>
      </div>

      <div class="card">
        <div class="card-title" title="Recent qvm-remote commands with exit codes and durations">Command History</div>
        <div class="row">
          <label>VM:</label>
          <select id="qr-hist-vm" class="vm-selector" style="width:180px"><option value="">(all VMs)</option></select>
          <label style="min-width:auto">Lines:</label>
          <input type="number" id="qr-hist-lines" value="50" style="width:60px;flex:none">
          <button onclick="loadCmdHistory()" title="Load command history">Load</button>
        </div>
        <div class="output" id="qr-history" style="max-height:300px"></div>
      </div>
    </div>

    <!-- ═══ Policy Enforcer ═══ -->
    <div class="page" id="page-policy">
      <h2 title="Restrict which VMs can be modified, protect dom0, and set per-VM permission pools">Policy Enforcer</h2>
      <p class="expl">
        Controls which operations the web admin can perform on each VM.
        <strong>dom0 is excluded from modification by default</strong> &mdash; only reading is allowed.
        Assign VMs to permission pools like the Qubes 4.3 device attachment panel: selectively grant
        <em>deny</em>, <em>monitor</em>, <em>manage</em>, or <em>full</em> access per VM.
      </p>

      <!-- dom0 protection -->
      <div class="card">
        <div class="card-title" title="dom0 is the most sensitive domain. By default, no modifications are allowed through the web UI.">dom0 Protection</div>
        <p style="font-size:12px;color:var(--soft);margin:0 0 8px">
          dom0 permission controls all direct command execution, service management, backups, and system updates.
          <strong>deny</strong> (default) blocks all modifications. <strong>monitor</strong> allows read-only views.
          <strong>manage</strong> allows service control. <strong>full</strong> allows arbitrary command execution.
        </p>
        <div class="row" style="align-items:center;gap:10px">
          <label style="min-width:auto;font-weight:600">dom0 level:</label>
          <select id="pol-dom0-level" style="width:140px;padding:6px 10px;border:1px solid var(--border);border-radius:4px;background:var(--card);color:var(--fg)" title="Permission level for dom0 operations">
            <option value="deny">deny (default)</option>
            <option value="monitor">monitor (read-only)</option>
            <option value="manage">manage (services + prefs)</option>
            <option value="full">full (unrestricted)</option>
          </select>
          <button class="btn-danger" onclick="setDom0Level()" title="Apply the selected dom0 permission level">Apply</button>
          <span class="d" id="pol-dom0-dot" title="Current dom0 status">&#x25cf;</span>
          <span id="pol-dom0-current" style="font-size:12px;color:var(--soft)"></span>
        </div>
        <div style="margin-top:8px">
          <label style="display:inline-flex;align-items:center;gap:6px;cursor:pointer" title="When enabled, read-only operations (status, qvm-ls, logs, xen info) work even if dom0 permission is 'deny'. Disable to fully lock out the web UI from dom0.">
            <input type="checkbox" id="pol-dom0-read" checked> Allow dom0 read even when denied
          </label>
          <button style="margin-left:8px" onclick="setDom0Read()" title="Save the dom0 read toggle">Save</button>
        </div>
      </div>

      <!-- Default policy -->
      <div class="card">
        <div class="card-title" title="Default permission for VMs not explicitly listed below">Default VM Policy</div>
        <p style="font-size:12px;color:var(--soft);margin:0 0 8px">
          VMs not in the assignment table below inherit this default permission level.
          <strong>monitor</strong> (default) allows viewing status, prefs, and logs but blocks modifications.
        </p>
        <div class="row" style="align-items:center;gap:10px">
          <label style="min-width:auto;font-weight:600">Default:</label>
          <select id="pol-default-level" style="width:140px;padding:6px 10px;border:1px solid var(--border);border-radius:4px;background:var(--card);color:var(--fg)" title="Default permission for unlisted VMs">
            <option value="deny">deny</option>
            <option value="monitor">monitor (default)</option>
            <option value="manage">manage</option>
            <option value="full">full</option>
          </select>
          <button class="btn-primary" onclick="setDefaultLevel()" title="Apply default policy">Apply</button>
          <span id="pol-default-current" style="font-size:12px;color:var(--soft)"></span>
        </div>
      </div>

      <!-- VM assignments (like device attachment panel) -->
      <div class="card">
        <div class="card-title" title="Assign per-VM permission levels &#8212; similar to Qubes 4.3 device assignment panel">VM Permission Assignments</div>
        <p style="font-size:12px;color:var(--soft);margin:0 0 8px">
          Override the default policy for specific VMs. Select a VM and assign one of four permission levels.
          This works like the Qubes 4.3 device attachment panel &mdash; each entry is an explicit assignment.
        </p>
        <div style="margin-bottom:10px;padding:8px;background:var(--bg);border:1px solid var(--border);border-radius:4px">
          <table style="width:100%;font-size:13px;border-collapse:collapse" id="pol-vm-table">
            <thead>
              <tr style="border-bottom:2px solid var(--border);text-align:left">
                <th style="padding:4px 8px" title="VM name">VM</th>
                <th style="padding:4px 8px" title="Assigned permission level">Permission</th>
                <th style="padding:4px 8px" title="What the level allows">Allows</th>
                <th style="padding:4px 8px">Action</th>
              </tr>
            </thead>
            <tbody id="pol-vm-tbody"></tbody>
          </table>
        </div>
        <div class="row" style="align-items:center;gap:10px">
          <label style="min-width:auto;font-weight:600" title="Select a VM to add or update">VM:</label>
          <select id="pol-add-vm" style="width:200px;padding:6px 10px;border:1px solid var(--border);border-radius:4px;background:var(--card);color:var(--fg)" title="Select VM to assign permissions"></select>
          <label style="min-width:auto;font-weight:600">Level:</label>
          <select id="pol-add-level" style="width:140px;padding:6px 10px;border:1px solid var(--border);border-radius:4px;background:var(--card);color:var(--fg)" title="Permission level to assign">
            <option value="deny">deny</option>
            <option value="monitor">monitor</option>
            <option value="manage">manage</option>
            <option value="full">full</option>
          </select>
          <button class="btn-primary" onclick="assignVmPolicy()" title="Add or update the VM permission assignment">Assign</button>
        </div>
      </div>

      <!-- Blocked commands -->
      <div class="card">
        <div class="card-title" title="Command patterns that are always blocked, regardless of permission level">Blocked Command Patterns</div>
        <p style="font-size:12px;color:var(--soft);margin:0 0 8px">
          Commands matching any of these patterns are <strong>always rejected</strong>, even with 'full' permission.
          One pattern per line. Substring match (e.g., "rm -rf /" blocks any command containing that string).
        </p>
        <textarea id="pol-blocked" rows="6" style="width:100%;font-family:monospace;font-size:12px;padding:8px;border:1px solid var(--border);border-radius:4px;background:var(--bg);color:var(--fg);resize:vertical" title="Blocked command patterns, one per line"></textarea>
        <div class="row" style="margin-top:6px">
          <button class="btn-primary" onclick="saveBlockedCmds()" title="Save blocked command patterns">Save Blocked Patterns</button>
        </div>
      </div>

      <!-- Policy summary & reset -->
      <div class="card">
        <div class="card-title" title="Current policy file contents (JSON)">Policy Summary</div>
        <div class="output" id="pol-summary" style="max-height:250px;font-size:12px"></div>
        <div class="row" style="margin-top:8px">
          <button onclick="loadAdminPolicy()" title="Reload and display current policy">Refresh</button>
          <button class="btn-danger" onclick="if(confirm('Reset policy to defaults? dom0=deny, default=monitor, no VM overrides.'))resetPolicy()" title="Reset all policy settings to safe defaults">Reset to Defaults</button>
        </div>
      </div>

      <!-- Permission reference -->
      <div class="card">
        <div class="card-title">Permission Level Reference</div>
        <table style="width:100%;font-size:12px;border-collapse:collapse">
          <thead>
            <tr style="border-bottom:2px solid var(--border);text-align:left">
              <th style="padding:4px 8px">Level</th>
              <th style="padding:4px 8px">Read/Status</th>
              <th style="padding:4px 8px">Start/Stop</th>
              <th style="padding:4px 8px">Prefs/Tags/FW</th>
              <th style="padding:4px 8px">Execute/Files</th>
              <th style="padding:4px 8px">Devices</th>
            </tr>
          </thead>
          <tbody>
            <tr style="border-bottom:1px solid var(--border)">
              <td style="padding:4px 8px;font-weight:600;color:#e74c3c">deny</td>
              <td style="padding:4px 8px">&#x2717;</td><td style="padding:4px 8px">&#x2717;</td>
              <td style="padding:4px 8px">&#x2717;</td><td style="padding:4px 8px">&#x2717;</td>
              <td style="padding:4px 8px">&#x2717;</td>
            </tr>
            <tr style="border-bottom:1px solid var(--border)">
              <td style="padding:4px 8px;font-weight:600;color:#3498db">monitor</td>
              <td style="padding:4px 8px;color:#27ae60">&#x2713;</td><td style="padding:4px 8px">&#x2717;</td>
              <td style="padding:4px 8px">&#x2717;</td><td style="padding:4px 8px">&#x2717;</td>
              <td style="padding:4px 8px">&#x2717;</td>
            </tr>
            <tr style="border-bottom:1px solid var(--border)">
              <td style="padding:4px 8px;font-weight:600;color:#f39c12">manage</td>
              <td style="padding:4px 8px;color:#27ae60">&#x2713;</td><td style="padding:4px 8px;color:#27ae60">&#x2713;</td>
              <td style="padding:4px 8px;color:#27ae60">&#x2713;</td><td style="padding:4px 8px">&#x2717;</td>
              <td style="padding:4px 8px">&#x2717;</td>
            </tr>
            <tr>
              <td style="padding:4px 8px;font-weight:600;color:#27ae60">full</td>
              <td style="padding:4px 8px;color:#27ae60">&#x2713;</td><td style="padding:4px 8px;color:#27ae60">&#x2713;</td>
              <td style="padding:4px 8px;color:#27ae60">&#x2713;</td><td style="padding:4px 8px;color:#27ae60">&#x2713;</td>
              <td style="padding:4px 8px;color:#27ae60">&#x2713;</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="pending-bar" id="pending-bar">
      <span id="pending-count">0 unsaved changes</span>
      <button class="btn-primary" onclick="applyAllChanges()" style="margin-left:auto" title="Apply all pending changes">Apply</button>
      <button onclick="discardChanges()" title="Discard all pending changes">Discard</button>
    </div>

  </div>
</div>

<script>
const API = '';
let selectedVm = null;

function showPolicyToast(msg) {
  let toast = document.getElementById('policy-toast');
  if (!toast) {
    toast = document.createElement('div');
    toast.id = 'policy-toast';
    toast.style.cssText = 'position:fixed;top:12px;right:12px;z-index:9999;background:#c0392b;color:#fff;padding:12px 20px;border-radius:6px;font-size:13px;font-weight:500;box-shadow:0 4px 12px rgba(0,0,0,0.3);max-width:420px;cursor:pointer;transition:opacity .3s';
    toast.onclick = () => { toast.style.opacity = '0'; setTimeout(() => toast.remove(), 300); };
    document.body.appendChild(toast);
  }
  toast.style.opacity = '1';
  toast.innerHTML = '<strong>&#x1f6e1; Policy Denied</strong><br>' + msg.replace(/</g,'&lt;');
  clearTimeout(toast._timer);
  toast._timer = setTimeout(() => { toast.style.opacity = '0'; setTimeout(() => toast.remove(), 300); }, 6000);
}

// ── Global spinner ──
let _apiInFlight = 0;
function _showSpinner() {
  const s = document.getElementById('global-spinner');
  if (s) s.style.display = _apiInFlight > 0 ? 'inline' : 'none';
}

// ── Pending changes (save-and-apply) ──
const pendingChanges = {};
function _updatePendingBar() {
  const n = Object.keys(pendingChanges).length;
  const bar = document.getElementById('pending-bar');
  const cnt = document.getElementById('pending-count');
  if (bar) { bar.className = 'pending-bar' + (n > 0 ? ' visible' : ''); }
  if (cnt) { cnt.textContent = n + ' unsaved change' + (n !== 1 ? 's' : ''); }
}
function stageChange(key, apiPath, params, label) {
  pendingChanges[key] = {path: apiPath, params, label: label || key};
  _updatePendingBar();
}
async function applyAllChanges() {
  const keys = Object.keys(pendingChanges);
  if (!keys.length) return;
  const overlay = document.createElement('div');
  overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.4);z-index:10000;display:flex;align-items:center;justify-content:center';
  overlay.innerHTML = '<div style="background:#fff;padding:24px 32px;border-radius:8px;min-width:300px;box-shadow:0 8px 32px rgba(0,0,0,0.3)"><div style="font-weight:600;margin-bottom:12px">Saving changes...</div><div id="save-progress" style="font-size:12px"></div></div>';
  document.body.appendChild(overlay);
  const prog = overlay.querySelector('#save-progress');
  let ok = 0, fail = 0;
  for (let i = 0; i < keys.length; i++) {
    const c = pendingChanges[keys[i]];
    prog.textContent = (i+1) + '/' + keys.length + ': ' + c.label;
    const d = await api(c.path, c.params, 'POST');
    if (d.error || d.policy_denied) { fail++; prog.textContent += ' FAILED'; }
    else { ok++; delete pendingChanges[keys[i]]; }
  }
  prog.innerHTML = '<br><strong>' + ok + ' applied, ' + fail + ' failed</strong>';
  _updatePendingBar();
  setTimeout(() => overlay.remove(), fail > 0 ? 3000 : 1200);
}
function discardChanges() {
  for (const k of Object.keys(pendingChanges)) delete pendingChanges[k];
  _updatePendingBar();
  const cur = document.querySelector('.sidebar .tab.active');
  if (cur && tabLoaders[cur.dataset.page]) tabLoaders[cur.dataset.page]();
}

// ── VM selector population ──
let _vmListData = [];
async function refreshVmSelectors() {
  const d = await api('/api/vm-list');
  if (!d.vms) return;
  _vmListData = d.vms;
  document.querySelectorAll('select.vm-selector').forEach(sel => {
    const cur = sel.value;
    const keepFirst = sel.querySelector('option') && sel.querySelector('option').value === '';
    const firstOpt = keepFirst ? sel.querySelector('option').outerHTML : '<option value="">(select VM)</option>';
    sel.innerHTML = firstOpt;
    for (const v of d.vms) {
      const dot = v.state === 'Running' ? '\u25cf ' : '\u25cb ';
      const opt = document.createElement('option');
      opt.value = v.name;
      opt.textContent = dot + v.name + ' [' + v.cls + ']';
      sel.appendChild(opt);
    }
    if (cur) sel.value = cur;
  });
}

async function refreshAll() {
  await refreshVmSelectors();
  const cur = document.querySelector('.sidebar .tab.active');
  if (cur && tabLoaders[cur.dataset.page]) tabLoaders[cur.dataset.page]();
}

// ── Tab navigation ──
document.querySelectorAll('.sidebar .tab').forEach(tab => {
  tab.addEventListener('click', () => {
    document.querySelectorAll('.sidebar .tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
    tab.classList.add('active');
    const pageId = 'page-' + tab.dataset.page;
    const pg = document.getElementById(pageId);
    if (pg) pg.classList.add('active');
    refreshVmSelectors();
    const l = typeof tabLoaders !== 'undefined' ? tabLoaders : {};
    (l[tab.dataset.page] || (()=>{}))();
  });
});

// ── API helper ──
async function api(path, params={}, method='GET') {
  _apiInFlight++; _showSpinner();
  try {
    let r;
    if (method === 'POST') {
      r = await fetch(API + path, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(params)
      });
    } else {
      const qs = new URLSearchParams(params).toString();
      r = await fetch(API + path + (qs ? '?' + qs : ''));
    }
    const data = await r.json();
    if (data.policy_denied) {
      showPolicyToast(data.err || 'Operation denied by policy');
    }
    return data;
  } catch(e) {
    return {error: e.message};
  } finally {
    _apiInFlight--; _showSpinner();
  }
}

function dot(el, state, text) {
  el.innerHTML = '<span class="d ' + state + '">&#x25cf;</span> <span>' + esc(text) + '</span>';
}

function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }

// ── Connection monitor ──
async function pollHealth() {
  const h = await api('/api/health');
  const bar = document.getElementById('connbar');
  const dotEl = document.getElementById('conn-dot');
  const txt = document.getElementById('conn-text');
  bar.className = 'connbar';
  if (!h || h.error) {
    bar.classList.add('err'); dotEl.className = 'dot d err';
    txt.textContent = 'Server not responding';
  } else if (h.daemon && h.web && h.vm) {
    bar.classList.add('ok'); dotEl.className = 'dot d ok';
    txt.textContent = 'Connected -- daemon + web + ' + (h.vm_name||'VM') + ' healthy';
  } else if (h.daemon && h.web) {
    bar.classList.add('warn'); dotEl.className = 'dot d warn';
    txt.textContent = 'Daemon + web OK, ' + (h.vm_name||'VM') + ' not running';
  } else {
    bar.classList.add('err'); dotEl.className = 'dot d err';
    txt.textContent = 'Service(s) down -- check Dashboard';
  }
}
setInterval(pollHealth, 15000);
pollHealth();

// ── Dashboard ──
async function loadDashboard() {
  const d = await api('/api/status');
  if (d.error) return;
  const svc = document.getElementById('svc-status');
  dot(svc, d.daemon_running ? 'ok' : 'err', d.daemon_running ? 'Running' : 'Stopped');
  document.getElementById('svc-version').textContent = 'Version: ' + d.daemon_version;
  dot(document.getElementById('auto-status'),
      d.daemon_enabled ? 'ok' : 'warn',
      d.daemon_enabled ? 'Enabled' : 'Disabled');
  document.getElementById('config-view').textContent = d.config;
  loadQueueHealth();
}
loadDashboard();
refreshVmSelectors();
loadPanelInfo();


async function loadQueueHealth() {
  const d = await api('/api/queue-health');
  const el = document.getElementById('queue-status');
  const det = document.getElementById('queue-detail');
  if (d.rc === 0 && d.out) {
    const hasStale = d.out.includes('(not running)') === false;
    dot(el, 'ok', 'Queue checked');
    det.textContent = d.out;
    det.style.display = 'block';
  } else if (d.err) {
    dot(el, 'err', 'Queue check failed');
    det.textContent = d.err;
    det.style.display = 'block';
  } else {
    dot(el, 'warn', 'Could not check');
  }
}

async function queueAction(action) {
  const out = document.getElementById('queue-action-output');
  out.style.display = 'block';
  out.textContent = action + 'ing...';
  const d = await api('/api/queue', {action}, 'POST');
  out.textContent = (d.out||'') + (d.err||'');
  loadQueueHealth();
}

async function connectVm() {
  const vm = document.getElementById('conn-vm-name').value.trim();
  const key = document.getElementById('conn-vm-key').value.trim();
  if (!vm) return alert('Enter a VM name');
  document.getElementById('conn-output').textContent = 'Connecting ' + vm + '...';
  const params = {vm};
  if (key) params.key = key;
  const d = await api('/api/connect', params, 'POST');
  document.getElementById('conn-output').textContent = (d.out||'') + (d.err||'');
  if (d.rc === 0) { loadVmKeys(); pollHealth(); }
}

async function disconnectVm() {
  const vm = document.getElementById('conn-vm-name').value.trim();
  if (!vm) return alert('Enter a VM name');
  document.getElementById('conn-output').textContent = 'Disconnecting ' + vm + '...';
  const d = await api('/api/disconnect', {vm}, 'POST');
  document.getElementById('conn-output').textContent = (d.out||'') + (d.err||'');
  loadVmKeys(); pollHealth();
}

async function loadDaemonStatus() {
  const d = await api('/api/daemon-status');
  document.getElementById('conn-output').textContent = d.out || d.err || 'No data';
}

async function svcCtl(action) {
  const d = await api('/api/service', {action}, 'POST');
  if (d.error) alert(d.error);
  if (d.err && d.rc !== 0) alert('Error: ' + d.err);
  loadDashboard();
  pollHealth();
}

// ── Execute (SSE streaming) ──
let execSource = null;
function doExec() {
  const cmd = document.getElementById('exec-cmd').value.trim();
  if (!cmd) return;
  const timeout = document.getElementById('exec-timeout').value;
  dot(document.getElementById('exec-status'), 'warn', 'Running...');
  const out = document.getElementById('exec-output');
  out.textContent = '';
  if (execSource) { execSource.close(); execSource = null; }
  const qs = new URLSearchParams({cmd, timeout}).toString();
  execSource = new EventSource('/api/stream/exec?' + qs);
  execSource.onmessage = function(e) {
    try {
      const d = JSON.parse(e.data);
      if (d.line) { out.textContent += d.line; out.scrollTop = out.scrollHeight; }
      if (d.done) {
        execSource.close(); execSource = null;
        if (d.rc === 0) dot(document.getElementById('exec-status'), 'ok', 'Completed (exit 0)');
        else if (d.rc === 124) dot(document.getElementById('exec-status'), 'err', 'Timed out');
        else dot(document.getElementById('exec-status'), 'err', 'Failed (exit ' + d.rc + ')');
      }
    } catch(_) {}
  };
  execSource.onerror = function() {
    execSource.close(); execSource = null;
    dot(document.getElementById('exec-status'), 'err', 'Connection lost');
  };
}

// ── VMs ──
async function loadVmKeys() {
  const d = await api('/api/vm/keys');
  const list = document.getElementById('vm-list');
  list.innerHTML = '';
  selectedVm = null;
  if (d.vms && d.vms.length) {
    d.vms.forEach(v => {
      const row = document.createElement('div');
      row.className = 'perm-row';
      row.textContent = v;
      row.dataset.vm = v.split(/\s+/)[0];
      row.onclick = () => {
        list.querySelectorAll('.perm-row').forEach(r => r.classList.remove('selected'));
        row.classList.add('selected');
        selectedVm = row.dataset.vm;
      };
      list.appendChild(row);
    });
  } else {
    list.innerHTML = '<div class="perm-row" style="color:var(--misc)">No authorized VMs</div>';
  }
}

async function authorizeVm() {
  const vm = document.getElementById('auth-vm').value.trim();
  const key = document.getElementById('auth-key').value.trim();
  if (!vm || !key) return alert('Enter both VM name and key');
  const d = await api('/api/vm/authorize', {vm, key}, 'POST');
  document.getElementById('vm-output').textContent = (d.out||'') + (d.err||'');
  if (d.rc === 0) { document.getElementById('auth-vm').value = ''; document.getElementById('auth-key').value = ''; loadVmKeys(); }
}

async function revokeVm() {
  if (!selectedVm) return alert('Select a VM first');
  if (!confirm('Revoke ' + selectedVm + '? It will no longer be able to run commands.')) return;
  const d = await api('/api/vm/revoke', {vm: selectedVm}, 'POST');
  document.getElementById('vm-output').textContent = (d.out||'') + (d.err||'');
  loadVmKeys();
}

async function vmCtl(action) {
  const vm = document.getElementById('lc-vm').value.trim();
  if (!vm) return;
  const d = await api('/api/vm/control', {vm, action}, 'POST');
  if (d.running !== undefined) {
    document.getElementById('vm-output').textContent = vm + ' is ' + (d.running ? 'running' : 'NOT running');
  } else {
    document.getElementById('vm-output').textContent = (d.out||'') + (d.err||'');
  }
}

// ── Files ──
async function filePush() {
  const vm = document.getElementById('push-vm').value.trim();
  const src = document.getElementById('push-src').value.trim();
  const dst = document.getElementById('push-dst').value.trim();
  if (!vm || !src || !dst) return alert('Fill in all fields');
  document.getElementById('file-output').textContent = 'Pushing...';
  const d = await api('/api/file/push', {vm, src, dst}, 'POST');
  document.getElementById('file-output').textContent = (d.out||'') + (d.err||'') || 'Done (exit ' + d.rc + ')';
}

async function filePull() {
  const vm = document.getElementById('pull-vm').value.trim();
  const src = document.getElementById('pull-src').value.trim();
  const dst = document.getElementById('pull-dst').value.trim();
  if (!vm || !src || !dst) return alert('Fill in all fields');
  document.getElementById('file-output').textContent = 'Pulling...';
  const d = await api('/api/file/pull', {vm, src, dst}, 'POST');
  document.getElementById('file-output').textContent = (d.out||'') + (d.err||'') || 'Done (exit ' + d.rc + ')';
}

// ── Backup ──
async function checkBackup() {
  const d = await api('/api/backup/status');
  document.getElementById('bak-output').textContent = d.out || 'No output';
}

async function startBackup() {
  const dest = document.getElementById('bak-dest').value.trim();
  document.getElementById('bak-output').textContent = 'Starting backup to ' + dest + '...\nThis may take a very long time.';
  const d = await api('/api/backup/start', {dest}, 'POST');
  document.getElementById('bak-output').textContent = (d.out||'') + (d.err||'');
}

// ── Log ──
let _logRawText = '';
let _logAutoTimer = null;

function colorizeLog(text, el) {
  _logRawText = text;
  el.innerHTML = '';
  const lines = text.split('\n');
  for (const line of lines) {
    const span = document.createElement('span');
    span.textContent = line + '\n';
    if (/\berr(or)?\b|FAIL|FATAL|panic|traceback/i.test(line)) span.className = 'log-err';
    else if (/\bwarn(ing)?\b|WARN/i.test(line)) span.className = 'log-warn';
    else if (/\bdebug\b|DEBUG/i.test(line)) span.className = 'log-debug';
    else span.className = 'log-info';
    el.appendChild(span);
  }
  el.scrollTop = el.scrollHeight;
}

function filterLogOutput() {
  const q = (document.getElementById('log-search') || {}).value || '';
  const el = document.getElementById('log-output');
  if (!q) { colorizeLog(_logRawText, el); return; }
  const filtered = _logRawText.split('\n').filter(l => l.toLowerCase().includes(q.toLowerCase())).join('\n');
  colorizeLog(filtered || '(no matches for "' + q + '")', el);
}

function switchLogTab(name) {
  document.querySelectorAll('.log-subtab').forEach(t => t.classList.toggle('active', t.dataset.logtab === name));
  document.querySelectorAll('.log-panel').forEach(p => p.classList.toggle('active', p.id === 'logpanel-' + name));
  const loaders = {daemon: loadLog, journal: loadJournal, container: () => {}, autostart: loadAutoLog, configs: loadConfigFileList};
  (loaders[name] || (() => {}))();
}

function toggleLogAutoRefresh() {
  if (_logAutoTimer) { clearInterval(_logAutoTimer); _logAutoTimer = null; }
  if (document.getElementById('log-autorefresh').checked) {
    _logAutoTimer = setInterval(() => {
      const active = document.querySelector('.log-subtab.active');
      if (active) switchLogTab(active.dataset.logtab);
    }, 10000);
  }
}

async function loadLog() {
  const lines = document.getElementById('log-lines').value;
  const d = await api('/api/log', {lines});
  colorizeLog(d.log || 'No log data', document.getElementById('log-output'));
}

async function loadJournal() {
  const unit = document.getElementById('journal-unit').value;
  const lines = document.getElementById('journal-lines').value;
  const since = document.getElementById('journal-since').value;
  const d = await api('/api/journal', {unit, lines, since});
  colorizeLog(d.log || d.error || 'No journal entries', document.getElementById('journal-output'));
}

async function loadContainerSuggestions() {
  const vm = document.getElementById('clog-vm').value.trim();
  const sel = document.getElementById('clog-name-sel');
  sel.innerHTML = '<option value="">(loading...)</option>';
  if (!vm) { sel.innerHTML = '<option value="">(select VM first)</option>'; return; }
  const d = await api('/api/suggestions', {kind: 'containers', vm});
  sel.innerHTML = '<option value="">(select container)</option>';
  for (const n of (d.items || [])) {
    const o = document.createElement('option'); o.value = n; o.textContent = n;
    sel.appendChild(o);
  }
}

async function loadConfigFileList() {
  const d = await api('/api/config-inspect');
  const sel = document.getElementById('config-file-sel');
  sel.innerHTML = '<option value="">(select a config file)</option>';
  for (const f of (d.files || [])) {
    const o = document.createElement('option'); o.value = f.path; o.textContent = f.path + ' — ' + f.desc;
    sel.appendChild(o);
  }
}

async function loadConfigFile() {
  const path = document.getElementById('config-file-sel').value;
  if (!path) return;
  const d = await api('/api/config-inspect', {path});
  document.getElementById('config-file-desc').textContent = d.desc || '';
  const el = document.getElementById('config-file-output');
  if (d.error) { el.textContent = 'Error: ' + d.error; return; }
  el.textContent = d.content || '(empty file)';
}

// ── Device ──
async function loadDevice() {
  const d = await api('/api/device');
  document.getElementById('dev-info').textContent = d.info || 'No data';
  document.getElementById('dev-vms').textContent = d.vms || 'No data';
}

// ── OpenClaw ──
async function loadOpenClaw() {
  const d = await api('/api/openclaw/status');
  const ps = document.getElementById('oc-proxy-status');
  const gs = document.getElementById('oc-gw-status');
  dot(ps, d.proxy_healthy ? 'ok' : 'err', 'Proxy: ' + (d.proxy_healthy ? 'healthy' : 'not responding'));
  dot(gs, d.gateway_healthy ? 'ok' : 'err', 'Gateway: ' + (d.gateway_healthy ? 'healthy' : 'not responding'));
  const ct = document.getElementById('oc-containers');
  if (d.containers && d.containers.length) {
    ct.innerHTML = d.containers.map(c =>
      '<div>' + esc(c.name) + ' -- ' + esc(c.status) + ' -- ' + esc(c.ports) + '</div>'
    ).join('');
    ct.innerHTML += '<div style="margin-top:4px">Engine: ' + esc(d.engine) + '</div>';
  } else {
    ct.textContent = 'No OpenClaw containers found. Use Start to launch them.';
  }
}

async function ocCtl(action) {
  document.getElementById('oc-output').textContent = action + 'ing...';
  const d = await api('/api/openclaw/control', {action}, 'POST');
  document.getElementById('oc-output').textContent = (d.out||'') + (d.err||'');
  if (action !== 'logs') setTimeout(loadOpenClaw, 2000);
}

// ── Global Config ──
async function loadGlobalPrefs() {
  const d = await api('/api/qubes-prefs');
  document.getElementById('gp-prefs').textContent = d.out || d.error || 'No data';
}

async function setGlobalPref() {
  const prop = document.getElementById('gp-prop').value.trim();
  const val = document.getElementById('gp-val').value.trim();
  if (!prop || !val) return alert('Enter property and value');
  stageChange('global_prefs:' + prop, '/api/qubes-prefs', {prop, val}, 'Global ' + prop + '=' + val);
}

async function loadVmPrefs() {
  const vm = document.getElementById('vp-vm').value.trim();
  if (!vm) return;
  const d = await api('/api/vm/prefs', {vm});
  document.getElementById('vp-output').textContent = d.out || d.error || 'No data';
}

async function setVmPref() {
  const vm = document.getElementById('vp-vm').value.trim();
  const prop = document.getElementById('vp-prop').value.trim();
  const val = document.getElementById('vp-val').value.trim();
  if (!vm || !prop || !val) return alert('Fill in VM, property, and value');
  stageChange('vm_prefs:' + vm + ':' + prop, '/api/vm/prefs', {vm, prop, val}, 'Set ' + vm + ' ' + prop + '=' + val);
}

async function loadXen() {
  const d = await api('/api/xen');
  document.getElementById('xen-output').textContent =
    '=== xl info ===\n' + (d.info||'') + '\n=== xl list ===\n' + (d.list||'') + '\n=== xl uptime ===\n' + (d.uptime||'');
}

async function loadTemplates() {
  const d = await api('/api/templates');
  document.getElementById('tpl-output').textContent = d.out || 'No data';
}

async function dom0Update(action) {
  document.getElementById('upd-output').textContent = action === 'check' ? 'Checking...' : 'Updating (this may take a while)...';
  const d = await api('/api/dom0-update', {action}, 'POST');
  document.getElementById('upd-output').textContent = (d.out||'') + (d.err||'');
}

// ── Advanced ──
async function loadFirewall() {
  const vm = document.getElementById('fw-vm').value.trim();
  if (!vm) return;
  const d = await api('/api/firewall', {vm, action: 'list'});
  document.getElementById('fw-output').textContent = (d.out||'') + (d.err||'');
}

async function resetFirewall() {
  const vm = document.getElementById('fw-vm').value.trim();
  if (!vm) return;
  stageChange('firewall:' + vm + ':reset', '/api/firewall', {vm, action: 'reset'}, 'Reset firewall ' + vm);
}

async function addFirewallRule() {
  const vm = document.getElementById('fw-vm').value.trim();
  const rule = document.getElementById('fw-rule').value.trim();
  if (!vm || !rule) return alert('Enter VM and rule');
  stageChange('firewall:' + vm + ':add:' + rule, '/api/firewall', {vm, action: 'add', rule}, 'Add firewall rule ' + vm + ': ' + rule);
}

async function loadDevices(type) {
  const d = await api('/api/devices', {type});
  document.getElementById('dev-ctl-output').textContent = (d.out||'') + (d.error||'');
}

async function deviceCtl(action) {
  const vm = document.getElementById('dev-ctl-vm').value.trim();
  const port = document.getElementById('dev-ctl-port').value.trim();
  if (!vm || !port) return alert('Enter VM and port');
  const d = await api('/api/devices/ctl', {vm, port, action, type: 'usb'}, 'POST');
  document.getElementById('dev-ctl-output').textContent = (d.out||'') + (d.err||d.error||'');
}

async function loadFeatures() {
  const vm = document.getElementById('feat-vm').value.trim();
  if (!vm) return;
  const d = await api('/api/features', {vm});
  document.getElementById('feat-output').textContent = (d.out||'') + (d.error||'');
}

async function setFeature() {
  const vm = document.getElementById('feat-vm').value.trim();
  const feature = document.getElementById('feat-name').value.trim();
  const value = document.getElementById('feat-val').value.trim();
  if (!vm || !feature || !value) return alert('Fill in all fields');
  stageChange('feature:' + vm + ':' + feature, '/api/features', {vm, feature, value}, 'Set feature ' + vm + ' ' + feature + '=' + value);
}

async function loadTags() {
  const vm = document.getElementById('tag-vm').value.trim();
  if (!vm) return;
  const d = await api('/api/tags', {vm, action: 'list'});
  document.getElementById('tag-output').textContent = (d.out||'') + (d.error||'');
}

async function modTag(action) {
  const vm = document.getElementById('tag-vm').value.trim();
  const tag = document.getElementById('tag-name').value.trim();
  if (!vm || !tag) return alert('Enter VM and tag');
  stageChange('tag:' + vm + ':' + action + ':' + tag, '/api/tags', {vm, action, tag}, (action==='add'?'Add':'Del') + ' tag ' + vm + ':' + tag);
}

async function loadServices() {
  const vm = document.getElementById('svc-vm').value.trim();
  if (!vm) return;
  const d = await api('/api/services', {vm, action: 'list'});
  document.getElementById('svc-output').textContent = (d.out||'') + (d.error||'');
}

async function modService(action) {
  const vm = document.getElementById('svc-vm').value.trim();
  const service = document.getElementById('svc-name').value.trim();
  if (!vm || !service) return alert('Enter VM and service');
  stageChange('service:' + vm + ':' + action + ':' + service, '/api/services', {vm, action, service}, action + ' service ' + vm + ':' + service);
}

async function loadPolicies() {
  const d = await api('/api/policy', {action: 'list'});
  document.getElementById('pol-output').textContent = d.out || 'No policies found';
  const sel = document.getElementById('pol-name');
  if (sel && d.out) {
    sel.innerHTML = '<option value="">(select policy)</option>';
    const files = d.out.trim().split('\n').filter(f => f.trim());
    for (const f of files) {
      const o = document.createElement('option'); o.value = f.trim(); o.textContent = f.trim();
      sel.appendChild(o);
    }
  }
}

async function readPolicy() {
  const name = document.getElementById('pol-name').value.trim();
  if (!name) return;
  const d = await api('/api/policy', {action: 'read', name});
  document.getElementById('pol-output').textContent = d.out || d.error || 'Not found';
}

// ── OpenClaw VM controls ──
async function ocVmCtl(action) {
  const vm = document.getElementById('ocvm-name').value.trim();
  if (!vm) return;
  document.getElementById('ocvm-output').textContent = action + 'ing in ' + vm + '...';
  const d = await api('/api/openclaw/vm', {vm, action}, 'POST');
  document.getElementById('ocvm-output').textContent = (d.out||'') + (d.err||'');
}

async function getContainerLogs() {
  const selVal = (document.getElementById('clog-name-sel') || {}).value || '';
  const txtVal = (document.getElementById('clog-name') || {}).value.trim();
  const container = selVal || txtVal;
  const vm = document.getElementById('clog-vm').value.trim();
  const lines = document.getElementById('clog-lines').value;
  if (!container) return alert('Select or enter a container name');
  const d = await api('/api/container/logs', {container, vm, lines}, 'POST');
  colorizeLog((d.out||'') + (d.err||d.error||''), document.getElementById('clog-output'));
}

// ── Per-VM log ──
async function loadVmLog() {
  const vm = document.getElementById('log-vm').value.trim();
  const lines = document.getElementById('log-lines').value;
  const d = await api('/api/vm-log', {vm, lines});
  colorizeLog(d.log || 'No entries for this VM', document.getElementById('log-output'));
}

async function loadAutoLog() {
  const d = await api('/api/autostart-log');
  colorizeLog(d.log || 'No autostart log found', document.getElementById('autolog-output'));
}

// ── Policy Enforcer ──
const PERM_COLORS = {deny:'#e74c3c',monitor:'#3498db',manage:'#f39c12',full:'#27ae60'};
const PERM_DESC = {
  deny: 'All operations blocked',
  monitor: 'Read-only: status, list, logs, check',
  manage: 'Start/stop, prefs, features, tags, services, firewall',
  full: 'All operations including execute, files, device attach'
};

async function loadAdminPolicy() {
  const d = await api('/api/admin-policy', {action:'get'});
  if (d.error) { alert(d.error); return; }
  const p = d.policy;
  const vms = d.available_vms || [];
  document.getElementById('pol-dom0-level').value = p.dom0 || 'deny';
  const dot = document.getElementById('pol-dom0-dot');
  dot.style.color = PERM_COLORS[p.dom0] || PERM_COLORS.deny;
  document.getElementById('pol-dom0-current').textContent = 'Current: ' + (p.dom0||'deny');
  document.getElementById('pol-dom0-read').checked = p.dom0_read_allowed !== false;
  document.getElementById('pol-default-level').value = p.default || 'monitor';
  document.getElementById('pol-default-current').textContent = 'Current: ' + (p.default||'monitor');
  document.getElementById('pol-blocked').value = (p.blocked_commands||[]).join('\n');
  const tbody = document.getElementById('pol-vm-tbody');
  tbody.innerHTML = '';
  const assigned = p.vms || {};
  for (const [vm, level] of Object.entries(assigned).sort()) {
    const tr = document.createElement('tr');
    tr.style.borderBottom = '1px solid var(--border)';
    tr.innerHTML = '<td style="padding:4px 8px;font-weight:500">' + esc(vm) + '</td>' +
      '<td style="padding:4px 8px"><span style="color:' + (PERM_COLORS[level]||'inherit') +
      ';font-weight:600">' + esc(level) + '</span></td>' +
      '<td style="padding:4px 8px;font-size:11px;color:var(--soft)">' + (PERM_DESC[level]||'') + '</td>' +
      '<td style="padding:4px 8px"><button class="btn-danger" style="font-size:11px;padding:2px 8px" ' +
      'onclick="removeVmPolicy(\'' + esc(vm) + '\')" title="Remove this assignment (VM falls back to default)">Remove</button></td>';
    tbody.appendChild(tr);
  }
  if (!Object.keys(assigned).length) {
    const tr = document.createElement('tr');
    tr.innerHTML = '<td colspan="4" style="padding:8px;text-align:center;color:var(--soft);font-style:italic">No VM-specific assignments. All VMs use the default policy.</td>';
    tbody.appendChild(tr);
  }
  const sel = document.getElementById('pol-add-vm');
  sel.innerHTML = '';
  for (const vm of vms) {
    if (vm === 'dom0') continue;
    const opt = document.createElement('option');
    opt.value = vm; opt.textContent = vm;
    if (assigned[vm]) opt.textContent += ' (' + assigned[vm] + ')';
    sel.appendChild(opt);
  }
  document.getElementById('pol-summary').textContent = JSON.stringify(p, null, 2);
}

async function setDom0Level() {
  const level = document.getElementById('pol-dom0-level').value;
  if (level !== 'deny' && !confirm('Warning: Changing dom0 from "deny" allows web UI to modify dom0.\nSet dom0 to "' + level + '"?')) return;
  stageChange('policy:dom0_level', '/api/admin-policy', {action:'set_dom0', level}, 'Policy: dom0 = ' + level);
}

async function setDom0Read() {
  const val = document.getElementById('pol-dom0-read').checked ? 'true' : 'false';
  stageChange('policy:dom0_read', '/api/admin-policy', {action:'set_dom0_read', value:val}, 'Policy: dom0 read = ' + val);
}

async function setDefaultLevel() {
  const level = document.getElementById('pol-default-level').value;
  stageChange('policy:default', '/api/admin-policy', {action:'set_default', level}, 'Policy: default = ' + level);
}

async function assignVmPolicy() {
  const vm = document.getElementById('pol-add-vm').value;
  const level = document.getElementById('pol-add-level').value;
  if (!vm) return alert('Select a VM');
  stageChange('policy:vm:' + vm, '/api/admin-policy', {action:'set_vm', vm, level}, 'Policy: ' + vm + ' = ' + level);
}

async function removeVmPolicy(vm) {
  if (!confirm('Remove assignment for "' + vm + '"? It will fall back to the default policy.')) return;
  stageChange('policy:vm_remove:' + vm, '/api/admin-policy', {action:'remove_vm', vm}, 'Policy: remove ' + vm);
}

async function saveBlockedCmds() {
  const commands = document.getElementById('pol-blocked').value;
  stageChange('policy:blocked', '/api/admin-policy', {action:'set_blocked', commands}, 'Policy: update blocked commands');
}

async function resetPolicy() {
  if (!confirm('Reset ALL policy settings to defaults?')) return;
  const d = await api('/api/admin-policy', {action:'reset'}, 'POST');
  if (d.error) alert(d.error);
  loadAdminPolicy();
  for (const k of Object.keys(pendingChanges)) { if (k.startsWith('policy:')) delete pendingChanges[k]; }
  _updatePendingBar();
}

// ── Self-heal ──
async function doSelfHeal(forceRestart) {
  const out = document.getElementById('heal-output');
  out.textContent = 'Checking services...';
  if (forceRestart) {
    out.textContent += '\nForce restarting daemon...';
    await api('/api/service', {action: 'restart'}, 'POST');
    await new Promise(r => setTimeout(r, 2000));
  }
  const d = await api('/api/self-heal', {}, 'POST');
  if (d.actions) {
    out.textContent = d.actions.join('\n');
  } else if (d.policy_denied) {
    out.textContent = 'Policy denied: ' + (d.err || 'dom0 write not allowed');
  } else {
    out.textContent = d.error || JSON.stringify(d);
  }
  loadDashboard();
}

// ── Panel info ──
async function loadPanelInfo() {
  const d = await api('/api/panel-info');
  if (d.error) { document.getElementById('panel-info').textContent = d.error; return; }
  const lines = [
    '<strong>Hosted on:</strong> ' + esc(d.host) + ' (' + esc(d.bind) + ') &mdash; air-gapped, localhost only',
    '<strong>Connected VM:</strong> ' + esc(d.managed_vm) + (d.vm_ip ? ' (IP: ' + esc(d.vm_ip) + ')' : ''),
    '<strong>Transport:</strong> ' + esc(d.transport),
    '<strong>Policy file:</strong> <code>' + esc(d.policy_file) + '</code>',
    '<strong>dom0 level:</strong> ' + esc(d.dom0_level) + ' | <strong>Default:</strong> ' + esc(d.default_level),
    '<strong>Authorized VMs:</strong> ' + (d.authorized_vms||[]).map(v => esc(v) + ' (' + esc(d.vm_permissions[v]||'?') + ')').join(', '),
    '<strong>Network:</strong> ' + esc(d.network),
    '<strong>Socket:</strong> ' + esc(d.socket),
  ];
  document.getElementById('panel-info').innerHTML = lines.join('<br>');
}

// ── VM Run (in VM via qvm-run) ──
let vmRunSource = null;
function doVmRun() {
  const vm = document.getElementById('vmrun-vm').value;
  const cmd = document.getElementById('vmrun-cmd').value.trim();
  const dispvm = document.getElementById('vmrun-dispvm').checked;
  const no_auto = document.getElementById('vmrun-noauto').checked;
  const user = document.getElementById('vmrun-user').value.trim();
  const timeout = document.getElementById('vmrun-timeout').value;
  if (!cmd) return alert('Enter a command');
  if (!vm && !dispvm) return alert('Select a VM or enable DispVM');
  const out = document.getElementById('vmrun-output');
  const st = document.getElementById('vmrun-status');
  out.textContent = ''; st.innerHTML = '<span class="d warn">&#x25cf;</span> <span>Running...</span>';
  if (vmRunSource) vmRunSource.close();
  const qs = new URLSearchParams({vm, cmd, dispvm: dispvm?'true':'false', no_auto: no_auto?'true':'false', user, timeout}).toString();
  vmRunSource = new EventSource('/api/stream/vm-run?' + qs);
  vmRunSource.onmessage = function(e) {
    try {
      const d = JSON.parse(e.data);
      if (d.line) { out.textContent += d.line; out.scrollTop = out.scrollHeight; }
      if (d.done) {
        vmRunSource.close(); vmRunSource = null;
        st.innerHTML = '<span class="d ' + (d.rc===0?'ok':'err') + '">&#x25cf;</span> <span>Exit: ' + d.rc + '</span>';
      }
    } catch(err) {}
  };
  vmRunSource.onerror = function() { vmRunSource.close(); vmRunSource = null; st.innerHTML = '<span class="d err">&#x25cf;</span> <span>Connection lost</span>'; };
}

async function doVmRunApi() {
  const vm = document.getElementById('vmrun-vm').value;
  const cmd = document.getElementById('vmrun-cmd').value.trim();
  const dispvm = document.getElementById('vmrun-dispvm').checked;
  const no_auto = document.getElementById('vmrun-noauto').checked;
  const user = document.getElementById('vmrun-user').value.trim();
  const timeout = document.getElementById('vmrun-timeout').value;
  if (!cmd) return alert('Enter a command');
  const out = document.getElementById('vmrun-output');
  out.textContent = 'Running...';
  const d = await api('/api/vm-run', {vm, cmd, dispvm, no_auto, user, timeout: parseInt(timeout)}, 'POST');
  out.textContent = (d.out||'') + (d.err||d.error||'');
  document.getElementById('vmrun-status').innerHTML = '<span class="d ' + ((d.rc||0)===0?'ok':'err') + '">&#x25cf;</span> <span>Exit: ' + (d.rc||'?') + '</span>';
}

// ── VM Setup ──
async function doVmSetup() {
  const vm = document.getElementById('setup-vm').value;
  if (!vm) return alert('Select a VM');
  if (!confirm('Set up qvm-remote for "' + vm + '"? This will install the client, generate a key, and authorize it.')) return;
  const out = document.getElementById('setup-output');
  out.textContent = 'Setting up...';
  const d = await api('/api/vm/setup', {vm}, 'POST');
  if (d.steps) {
    out.textContent = d.steps.join('\n');
    if (d.error) out.textContent += '\nError: ' + d.error;
    if (d.ok) out.textContent += '\n\nSetup complete!';
  } else {
    out.textContent = d.error || JSON.stringify(d);
  }
  loadVmKeys();
}

// ── Template Install ──
async function doTemplateInstall() {
  const tpl = document.getElementById('tpl-install-vm').value;
  if (!tpl) return alert('Select a template');
  if (!confirm('Install qvm-remote client in template "' + tpl + '"? The template will be started and then shut down.')) return;
  const out = document.getElementById('tpl-install-output');
  out.textContent = 'Installing...';
  const d = await api('/api/template/install-client', {template: tpl}, 'POST');
  if (d.steps) {
    out.textContent = d.steps.join('\n');
    if (d.error) out.textContent += '\nError: ' + d.error;
    if (d.ok) out.textContent += '\n\nInstall complete!';
  } else {
    out.textContent = d.error || JSON.stringify(d);
  }
}

// ── OpenClaw config ──
async function loadOcConfig() {
  const d = await api('/api/openclaw/config', {action: 'get'});
  if (!d.config) return;
  const c = d.config;
  document.getElementById('oc-engine').value = c.engine || 'auto';
  document.getElementById('oc-proxy-port').value = c.proxy_port || 32125;
  document.getElementById('oc-gw-port').value = c.gateway_port || 18789;
  document.getElementById('oc-paths').value = (c.compose_paths || []).join(', ');
}

async function saveOcConfig() {
  const cfg = {
    action: 'save',
    engine: document.getElementById('oc-engine').value,
    proxy_port: parseInt(document.getElementById('oc-proxy-port').value) || 32125,
    gateway_port: parseInt(document.getElementById('oc-gw-port').value) || 18789,
    compose_paths: document.getElementById('oc-paths').value.split(',').map(s => s.trim()).filter(Boolean),
  };
  const d = await api('/api/openclaw/config', cfg, 'POST');
  if (d.ok) alert('OpenClaw config saved');
  else alert(d.error || 'Save failed');
}

// ── qvm-remote tab ──
async function loadConnMap() {
  const [keys, policy, vmlist] = await Promise.all([
    api('/api/vm/keys'), api('/api/admin-policy', {action:'get'}), api('/api/vm-list')
  ]);
  const el = document.getElementById('qr-conn-map');
  const authorized = keys.vms || [];
  const perms = (policy.policy||{}).vms || {};
  if (!authorized.length) { el.textContent = 'No authorized VMs'; return; }
  const running = new Set((vmlist.vms||[]).filter(v=>v.state==='Running').map(v=>v.name));
  let html = '<table style="width:100%;border-collapse:collapse"><thead><tr style="border-bottom:2px solid var(--border);text-align:left"><th style="padding:4px 8px">VM</th><th style="padding:4px 8px">Status</th><th style="padding:4px 8px">Permission</th></tr></thead><tbody>';
  for (const vm of authorized) {
    const isRunning = running.has(vm);
    const perm = perms[vm] || (policy.policy||{}).default || 'monitor';
    html += '<tr style="border-bottom:1px solid var(--border)"><td style="padding:4px 8px;font-weight:500">' + esc(vm) + '</td>';
    html += '<td style="padding:4px 8px"><span style="color:' + (isRunning?'#27ae60':'#95a5a6') + '">&#x25cf;</span> ' + (isRunning?'Running':'Halted') + '</td>';
    html += '<td style="padding:4px 8px">' + esc(perm) + '</td></tr>';
  }
  html += '</tbody></table>';
  el.innerHTML = html;
}

async function loadQrQueue() {
  const d = await api('/api/queue-health');
  document.getElementById('qr-queue').textContent = d.out || d.err || 'No data';
}

async function qrQueueAction(action) {
  const d = await api('/api/queue', {action}, 'POST');
  document.getElementById('qr-queue-output').textContent = (d.out||'') + (d.err||d.error||'');
  loadQrQueue();
}

async function loadCmdHistory() {
  const vm = document.getElementById('qr-hist-vm').value;
  const lines = document.getElementById('qr-hist-lines').value;
  const d = await api('/api/vm-log', {vm, lines});
  document.getElementById('qr-history').textContent = d.log || 'No history';
}

// ── Tab loader map update ──
const tabLoaders = {
  dashboard: () => { loadDashboard(); loadPanelInfo(); },
  log: () => { const a = document.querySelector('.log-subtab.active'); switchLogTab(a ? a.dataset.logtab : 'daemon'); },
  vms: loadVmKeys,
  execute: () => {},
  files: () => {},
  openclaw: () => { loadOpenClaw(); loadOcConfig(); },
  device: loadDevice,
  globalcfg: loadGlobalPrefs,
  vmtools: () => { loadPolicies(); },
  qvmremote: () => { loadConnMap(); loadQrQueue(); },
  backup: () => {},
  policy: loadAdminPolicy,
};

// ── Keyboard shortcuts ──
document.addEventListener('keydown', e => {
  if (e.ctrlKey && e.key === 'Enter') doExec();
});
</script>
</body>
</html>"""


# ── Main ─────────────────────────────────────────────────────────

def main():
    if "--help" in sys.argv or "-h" in sys.argv:
        print("qubes-global-admin-web -- Air-gapped web admin for Qubes OS")
        print()
        print("Usage: qubes-global-admin-web [--port PORT]")
        print()
        print("Serves on http://127.0.0.1:{} (localhost only)".format(PORT))
        print("Open in Firefox or Chrome in dom0.")
        print()
        print("Environment: QUBES_ADMIN_PORT (default: 9876)")
        sys.exit(0)

    port = PORT
    for i, arg in enumerate(sys.argv[1:]):
        if arg == "--port" and i + 2 < len(sys.argv):
            port = int(sys.argv[i + 2])

    server = ThreadedServer((HOST, port), Handler)
    url = "http://{}:{}".format(HOST, port)
    print("Qubes Global Admin Web v{}".format(VERSION))
    print("Serving on {}".format(url))
    print("Open in your browser (dom0, air-gapped, no internet required)")
    print("Press Ctrl+C to stop")

    # Try to open browser automatically
    try:
        subprocess.Popen(["xdg-open", url],
                         stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except OSError:
        pass

    signal.signal(signal.SIGINT, lambda *_: (server.shutdown(), sys.exit(0)))
    signal.signal(signal.SIGTERM, lambda *_: (server.shutdown(), sys.exit(0)))

    # Systemd watchdog: send READY and periodic WATCHDOG pings
    _sd_notify("READY=1")
    def _watchdog_loop():
        while True:
            time.sleep(25)
            _sd_notify("WATCHDOG=1")
    wdt = threading.Thread(target=_watchdog_loop, daemon=True)
    wdt.start()

    try:
        server.serve_forever()
    except KeyboardInterrupt:
        pass
    server.server_close()
    print("\nStopped.")


if __name__ == "__main__":
    main()
